.. highlight:: cpp

Основы программирования на C++
==============================

В этом разделе я опишу основы программирования на C++ для тех, кто уже умеет программировать
на каком-нибудь другом языке. Я буду предполагать, что вы знаете питон (потому что по нему
у меня есть :ref:`отдельный раздел<pythonBasics>`), но это не столь принципиально; вы поймете текст ниже, даже если 
вы знаете не питон, а какой-нибудь другой язык программирования (будь то паскаль или какой-нибудь другой язык).

В частности, я буду предполагать, что вы понимаете основные концепции программирования:
переменные, условный оператор, циклы, массивы, строки, функции и т.п. 
Я не буду объяснять, что эти концепции обозначают, буду лишь объяснять, как их написать
конкретно на C++.

Основная цель этого раздела — чтобы вы могли писать несложные программы, реализовывать алгоритмы 
и писать решения для олимпиадных задач. Поэтому я буду описывать лишь основы синтаксиса, совсем не касаясь
таких тем, как классы, шаблоны и т.п. — для простейших программ они не нужны.

В этот текст также интегрирован мой старый `пост про C++ <http://blog.algoprog.ru/cpp/>`_ в блоге алгопрога.

Общая информация про язык C++
-----------------------------

(Этот раздел не то чтобы необходим для базового изучения C++, но тем не менее очень полезен.
Если не хотите читать длинный текст, переходите к следующему разделу,
про среды разработки. Но лучше все-таки прочитайте, вам потом будет
проще понимать дальнейший текст.)

Про языки С и C++
~~~~~~~~~~~~~~~~~

Важно понимать, что есть *два разных* языка: C и C++ (читается соответственно «си» и «си-плюс-плюс»). 
Они довольно похожи; на самом деле,
язык C++ «вырос» из C и потому базовый синтаксис у них примерно одинаковый. Но
это все-таки два очень разных языка, и хотя в разговорной речи часто язык C++ называют просто «си»,
надо понимать, что это не одно и то же. Более того, понятно, что в C++ очень много фич, которых нет в C,
но в языке C тоже есть некоторое количество фич, которых нет в C++, поэтому даже неверно, что C является
просто «частью», подмножеством, языка C++.

Кроме того, хотя язык C++ унаследовал от C как базовый синтаксис, так и многие базовые конструкции
(способы записи массивов и строк, ввод-вывод данных и т.д.), тем не менее многие из этих конструкций
в C++ были также придуманы заново, с учетом особенностей именно языка C++. В результате получилось,
что в C++ многие вещи (в первую очередь как раз описанные выше массивы, строки и ввод-вывод)
можно сделать двумя способами: в стиле C и в true-стиле C++. Я буду ниже описывать именно C++-way,
и именно его и надо использовать, по крайней мере до тех пор, пока вы не начнете понимать отличия, 
преимущества и недостатки обоих способов. Вообще, в современном C++ в реальной жизни практически 
всегда используются именно конструкции в стиле C++, а конструкции в стиле C используются крайне редко.

Тем не менее, во многих учебниках и источниках информации вы можете столкнуться именно с конструкциями 
в стиле C, не удивляйтесь. Их не надо использовать, а такие учебники не надо читать; благо учебников 
и хороших книг и вообще источников информации по C++ очень много. Я ниже буду приводить конструкции в стиле C
чисто «для сведения», не разъясняя, как они работают, но просто чтобы вы не удивлялись, если их увидите.

(А еще есть язык C#, который на самом деле имеет очень мало отношения к C и C++; про него мы не будем говорить.)

Строгая типизация и компилируемость
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В отличие от питона, C++ — *компилируемый* и *строго типизированный* язык.
Это обозначает следующее.

Компилируемость
```````````````

Для начала, компилируемость. Если питоновскую программу после написания вы просто сразу запускаете
(точнее, запускаете питон, чтобы он выполнил вашу программу), то на C++ запуск написанной программы
состоит из двух шагов. Сначала вы должны *скомпилировать* ваш код — запустить специальную программу,
называемую *компилятор C++* (который собственно и умеет понимать язык C++), в результате у вас получится
*исполняемый файл* (.exe под Windows), который вы можете уже запускать напрямую, без C++. И собственно
вторым шагом вы уже запускаете этот исполняемый файл.

Этот исполняемый файл можно запускать уже без C++, вы даже можете его скопировать на другой компьютер,
где C++ не установлен, и запустить там (тут надо сделать оговорку, что ваша программа, конечно, может 
потребовать дополнительных библиотек для запуска, но для простейших программ никаких дополнительных
библиотек не надо). Это свойство, конечно, очень полезно, если вы планируете распространять свою программу
(например, если вы написали программу на питоне и хотите ее распространять, то вам, возможно,
придется распространять ее вместе с самим интерпретатором питона; а на C++ достаточно распространять .exe-файл),
но для наших целей это пока не особо важно. Важнее другие два момента.

Во-первых, программы на C++ работают намного быстрее, чем на питоне — в первую очередь как раз за счет предварительной компиляции,
потому что скомпилированный код уже напрямую выполняется на процессоре, ему не нужен никакой посредник
типа интерпретатора как у питона.

Во-вторых, во время компиляции компилятор проводит много проверок вашего кода, и многие ошибки, 
которые на питоне были бы обнаружены только во время запуска (да и то если повезет), на C++ будут
обнаружены во время компиляции — ваша программа при наличии таких ошибок просто не скомпилируется. 
Например, если в питоне вы можете спокойно использовать неизвестную переменную или функцию,
и программа будет прекрасно работать, пока она не доберется до собственно этого использования, то на C++
подобная программа просто не скомпилируется.

Простейший пример:

.. code-block:: python

    a = int(input())
    if a == 2:
        prnt("Yes")

Тут опечатка в названии функции ``print``. Но она будет обнаружена только если вы введете ``a==2``.
Если вы введете любое другое число, то питон не пойдет в ``if``, и не заметит, что вы вызываете несуществующую функцию.

В C++ же подобные опечатки будут обнаружены сразу на этапе компиляции, программа просто не скомпилируется.
C++ прямо на этапе компиляции проходит по всем if'ам, по всем возможным веткам выполнения программы
и выполняет много проверок — точнее на самом деле это не просто проверки; чтобы скомпилировать программу, компилятору
надо записать в exe-шник, где именно (по какому адресу в пямати) находится функция, которую надо вызвать,
и поэтому компилятор заметит вызов неизвестной функции, он просто не сможет указать ее адрес в exe-шнике, 
поэтому выдаст ошибку. 

И это относится не только к неизвестным функциям, но и к ряду других ошибок, которые в питоне могли обнаруживаться
только на этапе выполнения программы.

Строгая типизация
`````````````````

Второе радикальное отличие C++ от питона — это строгая типизация. В питоне вы могли в одной и той же переменной хранить
то число, то строку, то массив и т.д. Следующий код на питоне совершенно корректен:

.. code-block:: python

    a = 20  # записали в переменную a число
    a = "Test"  # в ту же переменную записали строку вместо числа
    a = []  # или массив

В C++ такое недопустимо. В C++ каждая переменная имеет конкретный тип, указываемый заранее
(при объявлении переменной, см. ниже), и не может изменяться во время работы программы.
Вы сразу когда пишете код указываете, какого типа данные будут храниться в какой переменной,
и компилятор это проверяет сразу в процессе компиляции. 

Частный эффект строгой типизации — это то, что в любом выражении компилятор
может осуществить проверку того, что там не перепутаны переменные разных типов. 
Для примера, рассмотрим следующий код на питоне:

.. code-block:: python

    a = input()
    if a == 2:
        print(a // 2)

Тут забыто ``int``, поэтому в переменной ``a`` оказывается строка.
Поэтому когда вы сравниваете ``a`` с числом ``2``, сравнение всегда окажется ложным.
Но питон это проглотит без проблем: питон вполне разрешает сравнивать строку с числом
(просто всегда получается ``False``). C++ же в аналогичной ситуации выдал бы ошибку компиляции.
(Естественно, для этого вы должны заранее сказать C++, какого типа будет переменная ``a``,
но как раз про это я и буду писать ниже.)

Дальше в этом же коде написано ``a//2``. Но строки нельзя делить пополам.
На питоне это будет ошибкой, но она будет обнаружена только когда исполнение кода 
дойдет до этой строчки (аналогично примеру с ``prnt`` выше). В данной конкретной программе
исполнение никогда не дойдет до этой строчки (потому что условие ``if`` никогда не выполнится),
но даже если вы перепишете условие на ``if a=="2"``, то ошибка с делением в программе останется,
но будет проявляться только когда ``a=="2"``. При невнимательном тестировании вы легко можете
это не заметить. (И это, конечно, очень простой пример; в реальных программах, конечно,
все бывает намного запутаннее). C++ же в аналогичной программе еще при компиляции заметит, 
что вы пытаетесь поделить строку на число, и выдаст ошибку.

Поначалу может показаться, что строгая типизация — это не очень удобно. На питоне вы могли 
жонглировать типами данных как хотели, и (если вы все написали аккуратно) все работало бы.
А на C++ вы должны следить за типами, явно их заранее указывать и т.д.
Но на самом деле как только вы начинаете писать хоть сколько-то сложные программы,
строгая типизация становится очень удобной.
Даже в наших алгоритмических задачах вы это заметите, как только у вас в программе будет больше
десятка переменных или несколько функций; ну а в реальной жизни, когда объем программ
измеряется тысячами, десятками и сотнями тысяч строк, это, конечно, очень удобно.

.. note::

    Есть известная шутка, что если программа на C++ скомпилировалась, то в ней нет ошибок,
    она будет работать ровно так, как и ожидалось.
    Это, конечно, шутка; есть очень много ошибок, которые компилятор C++ не заметит,
    и в наших алгоритмических задачах вы, конечно, это прочувствуете сполна.

    Но, как и в любой шутке, в ней есть доля правды. Ошибки вида использования неизвестной функции
    или ошибки с типами, конечно, очень распространены — в тех языках, в которых нет средств контроля
    за этим. А если компилятор (или кто-нибудь еще) тщательно следит за типами, то все такие ошибки
    становятся невозможны. Это особенно проявляется в больших программах, где вы работаете
    вовсе не с простейшими типами — числами, строками и т.д. — а со сложными структурами и классами,
    когда вы используете объектно-ориентированное программирование по максимуму (ну или другие
    аналогичные парадигмы программирования). 
    
    Представьте себе, что вы пишете программу, управляющую беспилотным автомобилем. У вас в программе,
    скорее всего, будет объект, отвечающий за работу с двигателем, у него будет отдельный тип ``Engine``
    и например будет метод ``accelerate`` (ускориться). И будет тип ``SteeringWheel``, отвечающий за работу
    с рулем, и у него будут методы ``turnLeft`` (повернуть налево) и ``turnRight`` (направо). Соответственно,
    вы можете по ошибке у объекта, отвечающего за работу с двигателем, вызвать метод ``turnLeft``, и наоборот.
    Если бы вы писали бы на питоне, это не было бы обнаружено до тех пор, пока соответствующий код
    не будет выполняться. А на C++ программа просто не скомпилировалась бы.

    Поэтому если программа, особенно большая, на C++ скомпилировалась, то как минимум вы вызываете
    корректные методы у корректных объектов. Конечно, ошибки вида «поворачиваем налево там, где надо было направо»,
    останутся, но все-таки многие ошибки, которые на питоне были бы пропущены, на C++ будут замечены.

    Собственно, поэтому многие современные языки с динамической типизацией (т.е. не требующие указывать
    типы переменных заранее) двигаются в сторону проверки типов тем или иным способом (type hints 
    в последних версиях питона, или движение от Javascript к TypeScript).

    (Все вышесказанное не значит, что языки с динамической типизацией плохие. У каждого языка есть
    свои достоинства и недостатки; и более того, та же динамическая типизация во многих случаях
    наоборот может быть достоинством, а строгая статическая типизация как в C++ может наоборот мешать.
    Все зависит от ситуации, от конкретной задачи и т.д.)

Стандарты и компиляторы
~~~~~~~~~~~~~~~~~~~~~~~

В отличие от многих других языков программирования, где зачастую есть «официальный», «эталонный» компилятор/интерпретатор/...
и возможно пара альтернативных (например, в питоне есть «официальный» питон — так называемой Cpython, и еще есть PyPy и 
пара совсем малоизвестных реализаций), в C++ есть довольно много разных компиляторов. Наиболее известные из них
— это GNU C++ Compiler (сокращенно G++ или GCC), Clang, Microsoft Visual Studio (сокращенно MSVS, это и среда разработки, и компилятор), и Intel C Compiler (ICC);
но также есть еще и многие другие, и среди них нет какого-то «эталонного».

Сам язык C++, поддерживаемый этими компиляторами, практически одинаковый. Компиляторы различаются, например, разными оптимизациями
или поддерживаемыми платформами (операционными системами, процессорами и т.д.); кроме того, в разных компиляторах могут быть различные небольшие дополнения к языку,
или какие-то редкие фичи могут не поддерживаться, иногда также бывают и более сильные отличия (в первую очередь MSVS известен тем,
что у них несколько свое мнение по поводу смысла некоторых конструкций C++, хотя последнее время они вроде двигаются
к унификации с другими компиляторами). Но на начальном уровне можно считать, что особой разницы между разными компиляторами нет. Поначалу вы столкнетесь, скорее всего,
с GCC и/или MSVS.

Кроме того, у языка C++ есть несколько разных «версий», именуемых «стандартами». Они обозначаются C++XY, где XY — две цифры, обозначающие год, когда был принят этот стандарт.
Стандарты существуют следующие: С++98, очень старый стандарт, С++03, который в каком-то смысле является «классическим» C++, C++11, в котором было добавлено много новых фич, 
некоторые из которых вам будут довольно удобны; C++14, который не особо отличается от C++11, но там тоже есть пара удобных вещей, C++17 и наконец C++20, который на данный момент
(ноябрь 2020) уже почти готов, но еще не совсем. Основные вещи, которые вам понадобятся поначалу, относятся к C++03, также я буду упоминать (и явно это указывать) 
фичи, добавленные в C++11. 

Понятно, что разные компиляторы и разные версии компиляторов различаются по тому, какие фичи из каких стандартов они поддерживают.
В принципе, сейчас (2020 г.) практически все компиляторы, которые вы встретите, поддерживают C++11, более новые версии нередко надо запрашивать явно.
Например, в тестирующих системах вы нередко можете выбирать, под каким стандартом вы хотите отправить вашу программу (например, вам могут предлагать варианты GNU C++/C++11 и GNU C++/C++14).
Как правило, имеет смысл выбирать наиболее свежий стандарт из доступных, но в целом поначалу вряд ли вам понадобятся фичи из C++17, да и скорее всего из C++14
тоже ничего вам не понадобится (хотя там есть пара удобных вещей). А вот C++11 действительно нужен.

.. note::

    Не случайно версии языка называются «стандартами». Существует официальные документы, которые так и называются — «стандарт C++», в которых подробно и формально 
    описан язык C++. Вот, к примеру, `черновик текущего стандарта (C++20) <https://eel.is/c++draft/>`_. Не надо его читать при начальном изучении языка,
    он написан очень сложно и формально, но знать о существовании такого документа полезно. Это по сути справочник даже не для программистов,
    пишущих на C++ (хотя и для них тоже), а для программистов, пишущих сами компиляторы C++. Именно за счет существования стандарта C++
    достигается такое единообразие в поведении разных компиляторов.

    Если в других языках, например, в питоне, есть эталонная реализация (интерпретатор), по ней есть документация, и если кто-то хочет написать новый интерпретатор питона,
    то он должен изучать как работает этот эталонный интерпретатор, то в C++ авторы компиляторов сверяются в первую очередь со стандартом; поэтому
    и не существует эталонного компилятора C++.

    Собственно, версии стандарта (C++98, C++03, C++11 и т.д.) — это как раз разные версии этого текста, официально утвержденные Международной организацей по стандартизации, ISO
    (которая утверждает стандарты на что угодно, начиная от форматов бумаги, например, A4, и заканчивая условными обозначениями по уходу за одеждой и тканями).

    Соответственно, процесс подготовки нового стандарта состоит в длительных обсуждениях (в том числе, конечно, авторами компиляторов) насчет того, что и как надо добавить
    или поменять в текущем стандарте, и потом текст финализируется и утверждается ISO. Естественно, это не значит, что все компиляторы сразу будут поддерживать
    новый стандарт, до полной поддержки может пройти еще несколько лет. Хотя, конечно, многие предложения и изменения в стандарт сначала проходят отработку и тестовую реализацию в существующих компиляторах,
    и многие компиляторы поддерживают наиболее популярные фичи новых стандартов еще до официального утверждения стандарта.

Среды разработки (IDE)
----------------------

Для C++ есть довольно много сред разработки (IDE) — программ-редакторов, в которых вы собственно будете набирать код и из которых вы будете запускать программы.
Наиболее распространены, в том числе на олимпиадах, три среды — Code::Blocks, Microsoft Visual Studio и CLion.
Я ниже вкратце опишу Code::Blocks и Visual Studio, потому что первая бесплатна, а у второй есть бесплатная версия.
У CLion нет общедоступной бесплатной версии, поэтому про него писать я не буду. Кроме того, в контексте обучения школьников 
я иногда встречаю упоминания среды Dev-C++. Но она очень старая, и используется очень редко;
в частности, на серьезных олимпиадах я ее, кажется, не встречал, поэтому не надо ее использовать.

В целом, для самого начала я рекомендую использовать Code::Blocks, но также стоит достаточно рано освоить и Visual Studio,
хотя бы потому, что бывают олимпиады, где вам предоставляют только ее.

Тем, кто занимается в `моем курсе <https://algoprog.ru>`_: если у вас возникают какие-либо проблемы
с IDE, обязательно пишите мне. Я вполне допускаю, что описания IDE ниже может быть недостаточно для того,
чтобы в них сразу разобраться.

Code::Blocks
~~~~~~~~~~~~

Это бесплатная кроссплатформенная среда разработки. Ее можно скачать с официального сайта http://codeblocks.org: 
`полный установщик под Windows, включая компилятор GCC <https://www.fosshub.com/Code-Blocks.html?dwl=codeblocks-20.03mingw-setup.exe>`_,
или `другие варианты установки, в том числе под другие ОС <http://codeblocks.org/downloads/26>`_.

Это достаточно простая IDE без особых заморочек, очень напоминает простые IDE из других языков программирования, 
типа Wing IDE для питона и встроенной IDE для Pascal ABC. Все просто: создаете новый файл, пишете код, запускаете 
кнопкой с зеленой стрелочкой (точнее, кнопкой с шестеренкой и зеленой стрелочкой, потому что вам обычно надо скомпилировать, 
и только потом запускать код). Все достаточно очевидно, и вряд ли тут требуются дополнительные разъяснения.

При этом после запуска и завершения программы Сode::Blocks задерживает окошко программы на экране, 
чтобы вы смогли посмотреть, что вывела ваша программа. В разных других руководствах по C++ вам могут предлагать 
использовать специальные конструкции типа ``system("pause")`` или ``getch``,
чтобы задержать выполнение программы на экране — не надо этого делать, Code::Blocks сам вам задержит программу.

Кроме того, у Code::Blocks есть две неочевидных особенности. 
Во-первых, когда вы сохраняете программу в первый раз, надо явно указать расширение файла ``.cpp``
(т.е. в диалоге сохранения файла написать не ``my_best_program``, а ``my_best_program.cpp``), 
иначе по умолчанию программа сохранится как ``.c`` и соответственно компилятор будет считать, 
что это программа на C, а не на C++.

Во-вторых, не так просто сделать, чтобы заработал дебаггер (хотя поначалу вам это и не надо). 
Для этого, во-первых, надо, чтобы дебаггер был установлен на компьютере (Code::Blocks использует компилятор gcc и дебаггер gdb, надо, 
чтобы они были установлены, хотя установщик, указанный выше, скорее всего их устанавливает), 
во-вторых, просто файлы, созданные по кнопке «New», Code::Blocks не будет отлаживать. 
Чтобы дебаггер заработал, надо в Code::Blocks создать «проект», и уже в «проект» добавить 
файл с исходным кодом (существующий или новый). Но это достаточно просто и прямолинейно.

Microsoft Visual Studio
~~~~~~~~~~~~~~~~~~~~~~~

(Не путайте с Visual Studio Code — это две совсем разных IDE.)

Это заметно более продвинутая, профессиональная, IDE. В полном варианте она платная, но есть вариант Visual Studio Community, 
который можно `скачать бесплатно с официального сайта Microsoft <https://visualstudio.microsoft.com/ru/vs/community/>`_.
(Ранее эта версия называлась Visual Studio Express.)

Она уже не такая простая, как Code::Blocks, в ней вы не можете просто так создать новый файл, в ней надо создавать «проект». 
Но в первом приближении это достаточно просто: через File — New project, дальше в диалоге выбираете тип проекта (про это см. ниже),
указываете, куда его сохранить, и т.д. При этом в Visual Studio есть еще понятие *solution* — это группа связанных проектов,
и поэтому при создании проекта будет несколько пунктов про solution.
Поначалу не так существенно, как отвечать на вопросы про solution — вы можете создавать отдельный solution
на каждую свою программу, можете сделать один solution и добавлять в него проекты, и т.п.

После создания проекта далее все тоже уже достаточно прямолинейно: пишете код, на панели инструментов есть кнопка с зеленой стрелкой,
она запускает программу (хотя лучше запускать через горячие клавиши F5 или Ctrl-F5, см. далее), и т.д.

Но тут есть две проблемы-особенности.

Во-первых, если вы просто так создадите проект, то студия не будет задерживать окошко программы на экране после завершения программы. 
Если вы хотите посмотреть, что ваша программа вывела на экран, вам надо будет добавлять в конец программы какую-нибудь 
задержку типа ``system("pause")`` или ``getch``. А это очень плохо, в частности, не все тестирующие системы хорошо к этому 
относятся (еще бы — вашей программе уже пора заканчивать работу, а она никак не завершается). Поэтому так делать не надо.

Вторая проблема — по умолчанию студия создает проект с включенными так называемыми pre-compiled headers, 
и в начале кода появляется строчка ``#include "pch.h"``. Нам это не нужно, это только мешает, 
потому что код с такой строчкой не будет компилироваться в тестирующей системе, а без нее 
не будет компилироваться у вас локально в студии.

Обе проблемы решаются правильным созданием проекта. А именно, при создании проекта надо явно убедиться, 
что вы указали два параметра для проекта: во-первых, это должно быть console application 
(это повлияет на задержку программы, см. ниже), во-вторых, это должно быть empty project (а это повлияет на pch). 

Как это сделать, зависит от версии Visual Studio (я выше писал только про VS Community, но вы можете встретиться,
особенно на олимпиадах или в школе/университете, и с другими версиями). В старых версиях в окошке создания 
проекта надо было выбрать тип проекта а-ля Console application, и уже далее в следующем окошке поставить галочку Empty 
project. В последних версиях надо выбрать тип проекта «Windows Desktop Wizard», по-русски «Мастер классических приложений Windows» 
(не «пустой проект», не «консольное приложение», а именно «wizard»/«мастер», его всегда непросто найти), 
и в следующем окошке в выпадающем меню выбрать Console application и поставить галочку Empty project.

Это может быть не так просто, но повторю еще раз: главное — явно указать Console Application, и явно указать Empty Project.
Если вы первый раз работаете в незнакомой версии, потратьте несколько минут и найдите, как это сделать.

Так вы создадите полностью пустой проект, в котором даже не будет файла, в который надо писать код. 
После этого через меню Project — Add new items добавляете новый .cpp-файл (или там же рядом 
можно добавить уже существующий cpp-файл), и дальше все понятно. После этого студия будет делать 
задержку после запуска программы, при условии, что вы ее правильным образом запускаете 
(я не помню точно — надо запускать программу то ли в режиме отладки, 
то ли наоборот без нее, т.е. то ли F5, то ли Ctrl-F5; попробуйте по-разному и разберитесь), ну и pch не будет.

Синтаксис C++
--------------