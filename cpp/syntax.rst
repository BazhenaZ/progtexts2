.. highlight:: cpp

Синтаксис C++
==============

Простейшая программа
--------------------

Простейшая программа, складывающая два числа, на C++ выглядит так::

    #include <iostream>

    using namespace std;

    int main() {
        int a, b;
        cin >> a >> b;
        int s = a + b;
        cout << s << endl;
        return 0;
    }

Давайте разберем ее по строчкам.

::

    #include <iostream>

Строчки, начинающиеся с символа ``#``, в C++ называются *директивами компилятора* (или более точно
— *директивами препроцессора*). В отличие от практически всех других конструкций языка,
они обязаны быть написаны на отдельной строке.

Директива ``#include <iostream>``, грубо говоря, подключает возможность работы с вводом с клавиатуры и выводом на экран.
В первом приближении директива ``#include`` в C++ аналогична ``import`` в питоне и ``using`` в паскале
— она дает вам возможность использовать в программе какие-то дополнительные функции и конструкции.

При этом в C++, в отличие от питона и паскаля, по умолчанию программе доступно очень мало всего.
Практически все функции, типы данных и т.д., за исключением очень-очень базового набора,
требуют своего ``#include``. В частности, вот даже ввод с клавиатуры, который доступен без всяких ``import``'ов
в питоне и без всяких ``using`` в паскале, в C++ требует отдельного ``#include``.

То, что указывается после ``#include``, называется *заголовочным файлом*. Не надо использовать термин «модуль»,
который используется в аналогичной ситуации в питоне и паскале; в C++ модули — это совсем другое
(и на самом деле доступны только начиная с C++20).

.. note ::

    Стоит отметить, что директива компилятора ``#include`` имеет очень простой смысл: она берет содержимое указанного файла 
    (в нашем случае ``iostream``, который входит в стандартный комплект поставки компилятора), и просто вставляет (include) его
    в то место вашей программы, где написана директива. Т.е. запись ``#include <iostream>`` обозначает указание компилятору 
    «прочитай содержимое файла ``iostream`` так, как будто оно просто было написано в данном месте текущего файла, после этого
    читай текущий файл дальше». Соответственно, в стандартном заголовочном файле ``iostream`` описаны *заголовки* функций,
    типов данных и т.д., нужных для работы с клавиатурой и экраном. Там могут быть описаны только заголовки, не полный код функций
    (код может быть уже скомпилирован в готовых библиотеках), но именно заголовки нужны компилятору, чтобы скомпилировать 
    дальше вашу программу. Собственно, поэтому файлы типа ``iostream`` и называются заголовочными и нередко имеют расширение ``.h``
    (от слова header — заголовок).

    На самом деле, директиву ``#include`` можно использовать не только для подключения заголовочных файлов, но и в любом другом месте,
    где вам надо вставить код из другого файла. Но так делать не надо за исключением крайне редких случаев, которые вряд ли вам в ближашее время понадобятся.

    Еще отмечу, что само существование директивы ``#include`` свидетельствует о том, что язык C++ (ну а точнее, язык C, из которого 
    директива унаследована) — очень древний язык программирования. Понятно, что необходимость как-то подключать
    код из других файлов возникла еще на заре языков программирования, и ясно, что конструкции, просто тупо включающие код
    из другого файла в текущее место в программе — это один из простейших способов это сделать, и при этом очень мощный способ.
    В более современных языках есть системы типа модулей, которые, с одной стороны, сложнее (в смысле реализации в компиляторе),
    но с другой стороны более аккуратные и имеют ряд преимуществ; конструкции типа ``#include`` в современных языках встречаются
    только в каких-нибудь простых языках разметки или т.п., когда сам язык достаточно простой.

Переходим к следующей строке.

::

    using namespace std;

Эта строка, как говорится, подключает namespace (пространство имён) ``std``. Без нее многие стандартные функции, типы, переменные и т.д.
надо было бы писать с префиксом ``std::``, например, писать ``std::cin`` вместо ``cin`` (``cin`` мы увидим дальше в программе).
Команда ``using namespace`` не дает вам использовать никакие новые функции (в отличие от ``#include``), она
просто меняет способ обращения к уже подключенным функциям.

В серьезных программах на C++ настоятельно не рекомендуется использовать команды ``using namespace``,
но в наших небольших программах их вполне можно использовать.

Пока вам не обязательно до конца понимать, что такое пространства имён, пока просто запомните эту команду, ну или прочитайте следующее примечание.

.. note ::

    Все функции, типы, переменные и т.д. (дальше для простоты буду говорить только про функции)
    в C++ распределены по *пространствам имён*. Есть глобальное пространство имен, куда попадают
    все функции, которые вы можете просто так объявить в программе; также когда вы пишете новые функции, вы можете их явно заключить
    в какое-либо пространство имен. Далее, если ваш код находится в каком-нибудь пространстве имен, он может напрямую обращаться
    только к функциям этого же пространства имен, а также к функциям глобального пространства имен (а также, на самом деле,
    к функциям родительских пространств имен — потому что структура пространств имен имеет вид дерева). Если же вам надо вызвать функцию
    из другого простанства имен, вам надо перед этой функцией явно написать название пространства имен и двойное двоеточие,
    например, функция ``fun`` из пространства имен ``other`` вызывается как ``other::fun``.

    Это все аналогично тому, как в питоне, если вы напишете, например, ``import math``, то функцию квадратного корня
    вы не можете вызывать как просто ``sqrt``, а должны писать ``math.sqrt``.

    Сделано это с очень простой целью: для любого языка программирования есть огромное количество библиотек, и в каждой библиотеке
    огромное количество функций. Конечно, в разных библиотеках могут быть функции с одним и тем же именем,
    например, в библиотеке работы с файлами может быть функция ``open`` для открытия файла, и в библиотеке для работы с сетью
    может быть функция ``open``, например, для открытия соединения с каким-нибудь сайтом.

    Соответственно, если вашей программе надо будет работать с обеими этими библиотеками, и вы будете в коде программы вызывать ``open``,
    то компилятор может не понять, какая из функций вам нужна. Для решения этой проблемы код каждой библиотеки помещают в свое пространство имен,
    и тогда, явно указав пространство имен, вы можете объяснить компилятору, какая именно функция вам нужна.

    В частности, почти все функции из стандартной библиотеки C++ (не из разных дополнительных библиотек, а именно те функции,
    которые входят в состав любого компилятора) находятся в пространстве имен ``std``. Соответственно, если вы написали ``#include <iostream>``,
    то вы подключили возможность работы с клавиатурой и экраном, но к соответствующим функциям и переменным надо обращаться через ``std::``,
    например, ``std::cin``.
    
    Конструкция же ``using namespace`` дает вам возможность использовать функции из указанного пространства имен 
    без явно указания названия пространства имен. В частности, написав ``using namespace std;``, вы можете использовать стандартные функции
    без префикса ``std::``. 
    
    В серьезных программах не рекомендуется использовать конструкцию
    ``using namespace`` — потому что она возвращает назад проблемы одинаковых названий функций, для решения которых
    пространства имен как раз и были придуманы. Но в наших небольших программах маловероятно, что у вас будет путаница 
    по названиям функций, поэтому обычно ``using namespace std;`` можно писать. (Хотя бывают и проблемы; например, насколько я помню,
    в некоторых компиляторах есть функция ``std::y1``. Если вы пишете ``using namespace std;``, то вы не можете 
    назвать переменную ``y1``. Но это вроде бы только какие-то отдельные компиляторы, и в наших программах
    в таких случаях проще переименовать переменную.)

    Еще стоит отметить, что в большинстве других языков (собственно, там, где есть четкое понятие *модуля*), пространства имен и модули —
    это одно и то же, название модуля и пространства имен совпадает, и вы подключаете модуль и подключаете (или не подключаете) пространство имен
    одной и той же командой. Например, в питоне вы можете написать ``import math``, и дальше писать ``math.sqrt``, или написать
    ``from math import *`` и дальше писать просто ``sqrt``; в этом смысле ``import math`` — это некоторый аналог ``#include``,
    а ``from math import *`` — аналог ``#include``, совмещенного с ``using namespace``. И поэтому в многих других языках программирования
    отдельного понятия пространства имен просто не существует; пространства имен — это просто модули. 
    
    А в C++ есть две независимые друг
    от друга концепции: пространства имен и заголовочные файлы, и они не обязаны как-то быть связанными. В одном заголовочном файле
    могут быть определены функции из разных пространств имен (хотя так делать не принято), и наоборот, функции одного пространства имен
    могут быть раскиданы по многим заголовочным файлам, и тогда их надо подключать отдельными ``#include``. Более того, даже 
    модули из C++20 не создают неявных новых пространств имен, как в других языках — даже в C++20 с модулями
    пространства имен используются так же, как и раньше.

    Сам термин «пространство имён» может показаться странным, и на самом деле это конечно калька с английского namespace,
    но смысл на самом деле понятен: это некоторое «пространство», область, в котором живут «имена» — имена функций, переменных, типов и т.д.
    Соответственно, все имена, которые есть в C++, распределены по этим пространствам, областям, которые не пересекаются между собой.
    И каждое такое пространство называется «пространство имён».

Следующая строка (дальше пойдет уже больше текста по делу и меньше примечаний)::

    int main() {

Эта строка определяет функцию ``main``, которая не принимает никаких аргументов и возвращает значение типа ``int`` (это самый стандартный
тип данных для целых чисел).
Это эквивалент записи ``function main():integer`` в паскале, или ``def main():` в питоне (только в отличие от питона, на C++
надо явно указывать, какого типа будет возвращаемое значение, в нашем случае это ``int``). 

В C++, в отличие от питона, паскаля и многих других языков, нет понятия «основного кода программы», который пишется вне всяких функций.
Любой (ну, почти любой) исполняемый код на C++ должен быть частью какой-то функции, и вот самый основной код программы — должен быть
написан внутри функции со специальным названием ``main``. Говоря по-другому, при старте программы на C++ автоматически запускается
функция с названием ``main``. Она должна быть в любой программе на C++, она должна быть ровно одна, и она должна, как и написано выше,
не принимать никаких параметров (хотя на самом деле есть вариант, когда она может принимать определенные параметры — он используется
для передачи параметров командной строки, но это вам пока не будет нужно), и возвращать ``int`` (про это поговорим ниже).

В целом про синтаксис функций мы тоже поговорим ниже, пока просто запомните, что основной код программы надо начинать с такой строки.

Открывающая фигурная скобка здесь обозначает, что начался код функции. Он будет продолжаться до парной закрывающей фигурной скобки
(аналогично ``begin``/``end`` в паскале; в отличие от питона, в C++ отступы не имеют значения для компилятора).

::

    int a, b;

Эта строка объявляет две переменные типа ``int``, переменные будут называться ``a`` и ``b``. Напомню, что ``int`` — это самый широкоупотребимый 
тип данных для целых чисел, подробнее про существующие типы данных мы поговорим ниже. Важно отметить, что при такой записи нет никакой гарантии 
того, что именно будет записано в переменных ``a`` и ``b``. В них может оказаться какие угодно значения; в частности,
вовсе не гарантируется, что там будут записаны нули. Некоторые компиляторы зануляют все переменные, но другие компиляторы этого не делают.
Поэтому всегда, если вам важно инициализировать переменные — явно указывайте, чему они должны быть равны. В нашем случае это пока не важно,
потому что эти переменные мы будем вводить с клавиатуры.

::

    cin >> a >> b;

Вводим переменные ``a`` и ``b`` с клавиатуры. Обратите внимание на довольно необычный синтаксис. Переменная ``cin`` — это так называемый поток
ввода с клавиатуры (от console input), два знака «больше» похожи на стрелочку, указывающую направление движения данных: из ``cin`` в ``a`` и в ``b``.
Так можно вводить любое количество переменных, просто дописываете далее ``>>`` и имя переменной.

В C++ ввод с клавиатуры устроен так, что в первом приближении не важно, разделяются числа пробелами или переводами строк.
Запись как написано выше считает число с клавиатуры, пропустив сначала лишние пробелы или переводы строк, если они там будут,
и потом считает еще одно число, опять же пропустив пробелы и переводы строк перед ним. 

.. note ::

    Такой «потоковый» ввод, конечно, намного удобнее, чем питоновский ввод через ``input()``, где вы должны каждый раз думать,
    сколько чисел вводится на какой строке. Может вызывать удивление, что в питоне нет именно потокового ввода, — но на самом деле это
    не удивительно: в реальной жизни потоковый ввод бывает нужен крайне редко; такие ситуации, что во входных данных у вас просто написаны числа,
    возникают крайне редко.

::

    int s = a + b;

Заводим новую переменную, ``s``, тоже типа ``int``, и сразу в нее записываем сумму чисел ``a`` и ``b``. Вот так можно сразу при создании переменной
записывать в нее нужное значение. Справа от знака ``=``, конечно, может быть любое выражение, в том числе и просто число, если мы 
сразу знаем, какое число нам нужно (т.е. можно, например, написать ``int cnt = 0;``, если мы хотим в переменную записать ноль).

Вообще, в C++ рекомендуется все переменные сразу при создании инициализировать, за исключением особых случаев типа ввода с клавиатуры.
В частности, поэтому рекомендуется создавать переменные лишь в тот момент, когда они уже вам понадобились.
Люди, переходящие с паскаля, любят объявлять все нужные переменные сразу в начале функции — так делать не надо.
Объявляйте каждую переменную только когда она уже понадобилась; например, как здесь — мы объявляем переменную ``s`` только когда она нам
уже стала нужна. Заодно часто в таких ситуациях мы сразу можем записать осмысленное значение в переменную (как в нашем примере — если бы мы объявляли бы
переменную ``s`` в начале функции, то мы не могли бы сначала записать туда ничего осмысленного.

::

        cout << s << endl;

Выводим ответ на экран. Здесь ``cout`` — это переменная, отвечающая за вывод на экран (console output), и на этот раз используются символы «меньше»,
тоже явно указывая направление движения данных: из ``s`` в ``cout``. Далее выводим ``endl`` — это специальная переменная, вывод которой в ``cout``
приводит к переводу строки. (На самом деле, как я буду писать ниже, не стоит пользоваться ``endl``, он довольно тормозит. Но для начала, и вообще
в программах, где объем выходных данных не очень большой, ``endl`` вполне можно писать.) (Также отмечу, что в данной конкретной программе перевод строки
особо не нужен, т.к. мы и так не собираемся больше никаких данных выводить. Если бы нам надо было дальше выводить что-то еще, то да, перевод строки
мог бы иметь смысл, а так он не особо нужен.)

::

        return 0;

Как и в других языках, команда ``return`` обозначает завершить работу функции и вернуть в место вызова указанное значение. 
Но тут мы находится в главной функции, ``main``, поэтому эта команда завершает выполнение программы.

А ноль тут получается *кодом возврата* (exit code) всей программы. Вообще, есть общепринятое соглашение во всех операционных системах,
что каждая запускаемая программа возвращает специальное число — так называемый *код возврата*, — который указывает,
успешно ли завершилась программа или нет, так, чтобы тот, кто запускал эту программу (сама ОС или какие-либо еще программы) 
мог понять, был ли вызов успешным. Тоже по общепринятому соглашению код возврата равный нулю обозначает, что
программа успешно завершилась, ненулевой же код обозначает что произошла какая-то ошибка.

Собственно, например, тестирующие системы анализируют код возврата вашей программы и, если он не ноль, то выставляют результат теста
«ошибка времени выполнения», ну или «ненулевой код возврата» (это на самом деле одно и то же).

Вот команда ``return`` в функции ``main`` в C++ как раз и указывает, какой код возврата должна вернуть ваша программа.
Мы пишем ``return 0``: это обозначает, что программа успешно завершилась. Мы могли бы написать, например, ``return 1``,
и тогда бы то, кто запускал программу, мог бы понять, что что-то пошло не так. (Например, Code::Blocks пишет код возврата — exit code —
в окошке программы после ее завершения.) В частности, если на каком-то тесте в тестирующей системе у вас ``main`` заканчивается с ``return 1``,
то вы скорее всего получите результат теста типа «ошибка времени выполнения» или «ненулевой код возврата».

В других языках программирования концепция кода возврата, конечно, тоже есть, просто в питоне и паскале, например, считается,
что если выполнение успешно дошло до конца основного кода, то код возврата будет ноль. Но вы наверняка встречали необходимость
явно указать код возврата — например, в конструкции ``sys.exit(0)`` ноль — это как раз код возврата, с которым надо завершить программу.

И как раз именно поэтому функция ``main`` должна возвращать тип ``int``, поэтому заголовок функции выглядит как ``int main() {``.

(На самом деле, сейчас в ``main`` можно не писать ``return 0`` — если вы определили функцию именно как ``int`` (а не ``void``, к примеру),
и в ней не было явного ``return``, то она возвращает ноль. Но лучше всегда явно писать ``return 0``, в частности, многие старые компиляторы
могли сделать какой попало код возврата, если явно не написать ``return 0``.)

::

    }

Ну и наконец последняя строка программы — закрывающая фигурная скобка, показывающая, что код функции ``main`` закончился. Это аналогично паскалевскому ``end``.
