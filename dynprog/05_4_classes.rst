Классы задач на ДП
------------------

Какие задачи на ДП бывают? Конечно, могут быть совершенно разные, но
чаще всего бывают и решаются методами ДП следующие классы задач.
(Кстати, тут все очень похоже на перебор.)

Подсчёт объектов, в том числе определение существования объекта
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Т.е. надо посчитать, сколько всего существует объектов с заданными
свойствами, или проверить, существует ли хотя бы один. Примеры таких
задач мы уже видели: первая задача про черепашку, задача про
01-последовательности и задача про монеты. Я думаю, более-менее понятно,
как решаются подобные задачи.

В такой задаче (особенно в задаче проверки существования объекта) могут
попросить вывести пример объекта — мы уже обсуждали, как это делается.

Нахождение оптимального объекта
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Требуется в некотором множестве объектов найти в некотором смысле
оптимальный. Такую задачу мы тоже уже видели: вторая задача про
черепашку. Здесь тоже могут попросить вывести это оптимальный объект, и
вы уже знаете, как это сделать.

Вывод :math:`k`-ого объекта
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Но есть ещё один тип задач, который мы ещё не рассматривали. Могут
попросить по данному :math:`k` вывести :math:`k`-ый в некотором порядке
объект. Например, пусть в задаче про 01-последовательности нас не просто
просят посчитать количество хороших последовательностей длины :math:`N`,
а просят вывести :math:`k`-ую в лексикографическом порядке из них
(конечно, гарантируя, что :math:`k` не превосходит общего количества
таких последовательностей).

Как это сделать? На самом деле это делается легко и весьма похоже на
вывод *какой-нибудь* хорошей последовательности, что по сути мы с вами
уже обсуждали. (Мы уже даже обсуждали, что можно легко сделать так,
чтобы выводился *первый* в лексикографическом порядке объект.) Поэтому
давайте предварительно методом ДП посчитаем количество хороших
последовательностей длины :math:`i` для всех :math:`i` от 1 до :math:`N`
(ну или от нуля, вам виднее). А дальше...

А дальше раньше мы писали процедуру :math:`out(i)`, которая выводила
*любую* хорошую последовательность длины :math:`i`. Теперь нам надо
выводить не какую попало, а вполне определённую — поэтому давайте
напишем процедуру :math:`out(i,k)`, которая будет выводить :math:`k`-ую
в лексикографическом порядке последовательность среди всех хороших
последовательностей длины :math:`i`.

Как это делать? Попробуем воспользоваться тем, что мы знаем, как
выглядит любая хорошая последовательность длины :math:`i`. Она либо
заканчивается на 0, перед чем идёт хорошая последовательность длины
:math:`i-1`, либо на 01, перед чем идёт хорошая последовательность длины
:math:`i-2`. Мы разделили последовательности длины :math:`i` на два
типа, но это нам ничего не даёт, т.к. если все последовательности длины
:math:`i` записать в отсортированном порядке, то последовательности этих
двух типов будут идти вперемешку. Может быть, тут можно будет найти
закономерность, но мы поступим по-другому.

Ясно, что нам бы хотелось так разбить последовательности длины :math:`i`
на группы, чтобы в отсортированном порядке шла сначала одна группа, а
потом только другая. Но это же легко! Просто записывая рекуррентное
соотношение, будем смотреть не на то, чем *заканчивается*
последовательность, а на то, чем она *начинается*. Совершенно аналогично
тому, как мы раньше решали эту задачу, здесь поймём, что хорошая
последовательность длины :math:`i` — это

либо 0, после чего идёт хорошая последовательность длины :math:`i-1`,

либо 10, после чего идёт хорошая последовательность длины :math:`i-2`,

откуда мы, в частности, приходим к тому же рекуррентному соотношению.
(На самом деле, конечно, с самого начала абсолютно очевидно, что у нас
тут все симметрично.) Но мы что-то заработали от такого переворота. А
именно, представим себе все последовательности длины :math:`i`,
отсортированные в лексикографическом порядке. Но ведь в этом порядке
будут идти *сначала* все последовательности первого типа, и *только
потом* — второго. А последовательностей первого типа :math:`ans[i-1]`,
второго — :math:`ans[i-2]`. Т.е. этот отсортированный список будет
выглядеть так:

.. math::

   \left.
   \begin{array}{l}
   \left.
   \begin{array}{c}
   \verb'0xxxx'\\
   \verb'0xxxx'\\
   \verb'0xxxx'
   \end{array}
   \right\} \mbox{всего $ans[i-1]$ последовательностей}
   \\
   \left.
   \begin{array}{c}
   \verb'10xxx'\\
   \verb'10xxx'
   \end{array}
   \right\} \mbox{всего $ans[i-2]$ последовательностей}
   \end{array}
   \hspace{0.5cm} 
   \right\} \parbox{6cm}{\raggedright всего $ans[i]=ans[i-1]+ans[i-2]$ последовательностей}

Теперь вспомним о нашей цели: написании процедуры :math:`out(i,k)`. Надо
вывести :math:`k`-ую последовательность в этом списке. Но тогда понятно,
что если :math:`k\leq ans[i-1]`, то ответ начинается на ноль, иначе на
10. Более того: ведь в пределах одной группы последовательности
отсортированы в лексикографическом порядке, т.е. первая группа — это
ноль, после которого идут последовательности длины :math:`i-1`, причём
тоже в лексикографическом порядке, и аналогично вторая группа! Поэтому
:math:`k`-ая последовательность длины :math:`i` — это: если
:math:`k\leq ans[i-1]`, то: ’0’, к которому приписана :math:`k`-ая
последовательность длины :math:`i-1`; иначе (:math:`k>ans[i-1]`): ’10’,
к чему приписана (внимание!) :math:`(k-ans[i-1])`-ая последовательность
длины :math:`i-2`. Это уже пишется легко; для вывода более коротких
последовательностей, естественно, воспользуемся рекурсивным вызовом:

::

    procedure out(i,k);
    begin
    ...
    if (k<=ans[i-1]) then begin
       write(0);
       out(i-1,k);
    end else begin
        write(10);
        out(i-2,k-ans[i-1]);
    end;
    end;

На месте многоточия, конечно, должна быть обработка особых случаев. Её,
конечно, делаем в лоб, и, как и раньше, она упрощается, если ввести
нулевые элементы:

::

    procedure out(i,k);
    begin
    if (i=0) then exit; //тут обязательно k=1; единственная последовательность длины 0 --- пустая строка
    if (i=1) then begin //тут k может быть 1 или 2
       if (k=1) then write(0)
       else write(1);
       exit;
    end;
    if (k<=ans[i-1]) then begin
       write(0);
       out(i-1,k);
    end else begin
        write(10);
        out(i-2,k-ans[i-1]);
    end;
    end;

Ещё раз напоминаю, что здесь подразумевается, что всегда
:math:`1\leq k\leq ans[i]`. Подумайте, почему, если из внешней программы
мы вызвали процедуру :math:`out` правильно, то и при всех рекурсивных
вызовах это свойство сохранится.

Итак, как в общем случае выводить :math:`k`-ый объект? Ну, во-первых,
надо динамически посчитать их количество. При этом динамика у вас обычно
основывается на разделении множества объектов на группы и суммировании
их количества — так надо организовать динамику так, чтобы по номеру
объекта можно было легко отнести его к одной из групп. Чаще всего это
получается просто за счёт того, что в отсортированном порядке сначала
идут все объекты первой группы, потом — второй и т.д.; нередко чтобы
добиться этого, приходится рассматривать, с чего *начинается* решение, а
не чем *заканчивается*, но обычно это делается примерно одинаково.
(Кстати, может быть, что разбиение на группы будет делаться как-нибудь
по-другому, например, по остатку от деления :math:`k` на что-нибудь, но
я примеров таких задач не знаю). После этого легко пишется процедура
:math:`out(i,k)`: вы определяете, какой группе принадлежит :math:`k`-ый
объект и в соответствии с этим выводите его, скорее всего пользуясь
рекурсивным вызовом.



.. task::

    Научитесь выводить :math:`k`-ый в лексикографическом порядке
    путь черепашки в задаче с подсчётом количества путей.
    |
    Конечно, будет
    удобно переписать динамику, аналогично ответу
    :ref:`tortoise:firstlex`, чтобы вообще было удобно работать с
    лексикографическом порядке, дальше все просто по стандартному сценарию.
    
    Можно не переписывать динамику, а «передумать» её, и не переписывать, но
    будет некоторое несоответствие между «текущей позицией» черепашки и
    координатами в массиве :math:`ans` (додумайте :) )
    |
    Я думаю, общий
    цикл насчета количества результатов вы напишите. Я приведу только
    процедуру :math:`out`. Сравните с ответом к
    :ref:`tortoise:firstlex`.
    
    ::
    
    procedure out(i,j,k); // k - номер решения, которое надо вывести
    begin
    if (i=N+1)or(j=M+1) then exit;
    if ans[i+1,j]<=k then begin
    write('R');
    out(i+1,j,k);
    end else begin
    write('U');
    out(i,j+1,k-ans[i+1,j]);
    end;
    end;
    
    
    |

.. _tortoise:kth:



Если у вас групп немного, то все это делается легко. Если же групп
много, то скорее всего придётся искать подходящую группу в цикле. Но это
тоже пишется легко, главное не испугаться:

::

    procedure out(i,k);
    ...
    for g:=1 to ng do
        if k<=nans[g] then begin
           ...
           out(ii,k);
           break;
        end else k:=k-nans[g];

Здесь (очень условно!) написано следующее. :math:`g` — это номер
очередной группы, :math:`ng` — их общее количество, :math:`nans` —
количество решений в этой группе. В реальной программе у вас почти
наверняка обозначения будут другие и даже способ организации цикла может
быть другим. Но суть в следующем: мы перебираем группы в
лексикографическом порядке и каждый раз уменьшаем :math:`k` на числе
объектов в очередной группе — :math:`k` в итоге обозначает, какой по
счету объект нам надо вывести, не считая тех, что мы уже пропустили. В
очередной момент :math:`k` станет :math:`\leq nans[g]`, т.е. станет
ясно, что ответ находится в этой группе — поэтому надо вывести
:math:`k`-ый объект из этой группы. (Точнее, сейчас, наверное, не ясно,
но наткнётесь когда-нибудь на пример — и будет ясно.)

Определение номера по объекту
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Задача, противоположная предыдущей: дан объект, определить его номер.
Решается аналогично, рассмотрим опять для примера задачу про
01-последовательности. Как определить номер данной последовательности?
Вспоминая, как мы находили последовательность по номеру, и применяя те
же соображения, получаем следующее решение: если данная нам
последовательность длины :math:`N` начинается на 0, то ответ будет
просто ответом для последовательности с откинутым этим нулём. Если же
начинается на единицу, то нужно эту единицу и следующий за ней ноль
откинуть, найти номер получившейся последовательности (естественно,
среди последовательностей длины :math:`N-2`), а потом к нему прибавить
:math:`ans[N-1]`. Додумайте эту идею сами.

Я надеюсь, что на этом примере идея нахождения номера по объекту ясна.



.. task::

    Напишите эту программу.
    |
    |
    Итак, нам дана хорошая
    последовательность :math:`a` длины :math:`n`, требуется найти её номер
    среди всех хороших последовательностей длины :math:`n`.
    
    Я никогда такого рода программ не писал, но попробую. Вероятность багов
    выше, чем в других кодах :). Сначала, как всегда в задачах на динамику,
    посчитаем основной динамикой :math:`ans[i]` — количество хороших
    последовательностей длины :math:`i`, а потом по данной
    последовательности :math:`a` найдём её номер. Я напишу только вторую
    часть; похоже, её даже проще тут реализовать нерекурсивно, но я попробую
    написать рекурсивно, чтобы была видна связь с нахождением объекта по
    номеру и более понятно обобщение на произвольный случай. Подумайте над
    нерекурсивной реализацией; это, по-моему, просто.
    
    Процедура :math:`getnum(i)` находит, какой по счету среди всех
    последовательностей длины :math:`i` является последовательность,
    образованная последними :math:`i` символами данной нам (т.е. находит
    номер последовательности :math:`a[(n-i+1)\ddots n]`).
    
    ::
    
    function getnum(i)
    begin
    if i=n then begin
    getnum:=1;
    exit;
    end;
    if (i=n+1) then begin //аналог нулевого элемента
    getnum:=1;
    end;
    if a[n-i+1]=0 then
    getnum:=getnum(i-1)
    else getnum:=ans[i-1]+getnum(i-2)
    end;
    
    Надеюсь, что правильно :)
    
    Кстати, тут тоже, аналогично задачам :ref:`tortoise:firstlex`,
    :ref:`tortoise:kth` и :ref:`tortoise:numberbypath`, можно
    переписать динамику, и в :math:`ans[i]` хранить количество
    последовательностей длины :math:`n-i+1` (т.е. количество возможных
    окончаний нашей последовательности, начиная с позиции :math:`i`), и
    тогда в процедуре не будет такого странного аргумента
    :math:`ans[n-i+1]`. Может быть, так будет проще. Во всяком случае, это
    объясняет, почему в задаче :ref:`tortoise:numberbypath` мы
    переделаем динамику, а здесь не переделывали: на самом деле обе задачи
    можно решить, не переделывая динамику, обе можно решить, переделав, я
    просто решил показать оба способа и, кроме того, в задаче
    :ref:`tortoise:numberbypath` мне кажется, что результат будет проще
    понять с переписанной динамикой.
    |

.. _01:numberbyseq:





.. task::

    Напишите программу определения номера по пути в задаче про
    черепашку с подсчётом числа путей.
    |
    Сначала сделайте задачи
    :ref:`tortoise:firstlex` и :ref:`tortoise:kth`, после этого эта
    задача сложностей составлять не должна.
    |
    Как и в задачах
    :ref:`tortoise:firstlex` и :ref:`tortoise:kth`, переписываем
    динамику, чтобы удобнее работать с лексикографическим порядком, хотя,
    как я отметил в ответе :ref:`01:numberbyseq`, можно её и не
    переписывать. Додумайте вариант без переписывания.
    
    Если же мы переписали динамику и уже насчитали массив :math:`ans`, то
    дальше все просто: :math:`getnum(i,j,k)` возвращает номер решения,
    образованного символами с :math:`k`-ого по последний данного нам массива
    :math:`a`, среди всех решений, формирующих :math:`ans[i,j]` (т.е. идущих
    из :math:`(i,j)` и :math:`(N,M)`). (Обратите внимание, что в ответе
    :ref:`01:numberbyseq` был один параметр :math:`i`, а не два
    параметра :math:`i` и аналог :math:`k`, т.к. там оба параметра имели бы
    одно и то же значение.)
    
    ::
    
    function getnum(i,j,k);
    begin
    if (i=N+1)or(j=M+1) then begin // можно написать и if k=N+M-1
    getnum:=1;
    exit;
    end;
    if ans[k]='R' then
    getnum:=getnum(i+1,j,k+1)
    write('R');
    out(i+1,j,k);
    end else
    getnum:=ans[i+1,j]+getnum(i,j+1,k+1);
    end;
    
    Ещё обратите внимание на следующий момент: когда вы только услышали
    такую задачу, может показаться, что тут есть какие-нибудь идеи, методы
    решения, специфические только для этой задачи (например, какая-нибудь
    игра с :math:`C_n^k`, а в задании :ref:`01:numberbyseq` — с числами
    Фиббоначчи). Нет! *Все* идеи тут совершенно стандартны, и ничего
    специфичного для задачи нет.
    |

.. _tortoise:numberbypath:


