Дополнительные идеи
===================

Отсечение по времени
--------------------

В реальных олимпиадных задачах у вас всегда есть ограничение времени,
превышать которое не стоит. Если ваша программа проработает больше
отведённого времени, то вы получится :math:`0` баллов за тест — ничего
хуже в этом тесте быть не может :) Поэтому имеет смысл избегать такого
результата всеми силами, в надежде, что, может быть, повезёт и получится
что-то лучше. А именно:

-  В задачах на оптимизацию (т.е. когда надо найти объект с оптимальными
   параметрами) можно, когда вы видите, что время подходит к концу,
   просто вывести лучший найденный на данный момент объект и завершить
   работу. Если повезёт и он на самом деле будет оптимальным, то тест
   будет зачтён, иначе хуже, чем TL, все равно не будет.

-  В задачах на поиск объекта ничего не остаётся, как вывести, что
   решения не существует (естественно, ваша программа должна также
   завершаться сразу, как только нашла решение). Кстати, это далеко не
   всегда бывает неправильно, даже наоборот: в хорошем наборе тестов
   обязательно должны быть большие тесты с ответом «решения не
   существует». Если же вам требовалось (редкий случай) вывести *все*
   решения, то ничего не остаётся, как их все найденные на данный момент
   и вывести, и завершить работу (про вывод *всех* решений см. ниже).

-  В задачах на подсчёт числа объектов ничего не остаётся, как вывести,
   сколько вы уже насчитали. Конечно, скорее всего это будет неправильно
   (ваша программа работала секунду, насчитала, допустим 1432 объекта, и
   хочет работать ещё секунду… неужто она не найдёт ни одного объекта
   больше? :) а если найдёт, то, значит, :math:`1432` — неверный ответ),
   но работать больше нельзя и ничего лучше тут, видимо, не придумаешь.

\|\|noteТестирование программы с отсечением по времени на компьютере
жюри выглядит весьма эффектно, особенно если вы смотрите непосредственно
в экран тестирующего компьютера, на котором пишется, сколько времени
осталось: время приближается к TL, и все уже готовы увидеть TL, но нет —
за доли секунды до TL ваша программа завершается, запускается чекер и вы
видите WA — что ж, не повезло — или OK — ура, повезло.

Как технически делать отсечение по времени? В Borland Pascal (как и в
любых DOS-программах) есть очень удобная вещь: по адресу 0:$46С (т.е. в
ячейке памяти с абсолютным номером :math:`46\mathrm C_{16}`) лежат
четыре байта, которые образуют переменную типа :math:`longint`. Её
значение автоматически (!) увеличивается на единицу примерно 18 раз в
секунду (за счёт прерывания таймера). Поэтому отсечение по времени можно
писать так:

::

    var t:longint absolute 0:$46c; 
          {такая конструкция с absolute позволяет указать абсолютный адрес, 
          где в памяти будет храниться значение переменной}
        t0:longint;
        
    procedure find(...)
    begin
    if i>k...
    end;
    if t>t0+18 then begin {считая, что ограничение времени 1 секунда}
       out; {процедура out выводит текущее найденное решение в выходной файл}
       halt;
    end;
    ...
    end;

    begin {основная программа}
    t0:=t; {сохраним начальный момент времени в t0}
    ...
    end.

может, стоит ставить 17, а не 18, на всякий случай, и т.п.

В Windows-программах все не так просто, в частности потому, что нужно
учитывать процессорное время, потраченное вашей программой. Насколько я
понимаю, есть функция :math:`getTickCount`, но считается, что она
подтормаживает и *каждый* раз в функции :math:`find` её вызывать — это
очень медленно. Тогда может иметь смысл завести ещё глобальную
переменную :math:`nn`, которая будет считать, сколько раз вы вошли в
:math:`find`, и только, например, каждый :math:`1024`-ый раз проверять.
Типа того:

::

    var t:longint;
        nn:longint;
        
    procedure find...
    begin
    if i>k...
    end;
    if (n and 1023=0)and(gettickcount>t0+1000) then begin
       ...
    end;
    inc(nn);
    ...

    ...

    begin
    t0:=gettickcount;
    nn:=0;
    ...
    end.

(``n0 and 1023``, а не ``n0 mod 1024``, поскольку первое работает
намного быстрее; по той же причине проверяю каждые 1024, а не каждые
1000 раз). На само деле, конечно, необходимая частота проверок сильно
зависит от задачи: иногда может понадобиться и каждый :math:`65\,536`-ой
раз проверять и т.п.; каждый раз стоит подбирать константу заново, чтобы
проверки были достаточно частыми, но не слишком частыми.

И ещё, конечно, можно это организовать и по-другому:

::

    if (n=1000) then begin
       n:=0;
       if (gettickcount>t0+1000) then begin
          ...
       end;
    end;
    inc(nn);

т.е. при проверке сбрасывать счётчик в ноль. Теперь взятие остатка по
модулю не нужно вообще, и можно работать с любым модулем. Но подобная
проверка все равно не сильно быстрее проверки по модулю «два в степени
:math:`k`\ », поэтому как вам больше нравится, так и пишите. Первый
способ позволяет вам также узнать в конце программы, сколько же раз на
самом деле вызывалась ваша функция.

Перебор двумерного массива
--------------------------

Иногда объекты, которые мы перебираем, проще представлять в виде
двумерного массива (а не одномерного, как было всегда раньше). Пусть,
например, надо перебрать все способы заполнения *матрицы*
:math:`N\times N` нулями и единицами. Можно это написать так:

::

    procedure find(i,j:integer); {i,j --- координаты клетки, которую перебираем}
    begin
    if i>n then begin {если кончилась вся матрица}
       check;
       exit;
    end;
    if j>n then begin {если кончилась текущая строка}
       find(i+1,1);   {то перейти к следующей} 
       exit;
    end;
    a[i,j]:=0;
    find(i,j+1);
    a[i,j]:=1;
    find(i,j+1);
    end;

Осознайте этот пример.

Вариации порядка выбора элементов
---------------------------------

(Это не то, что обсуждалось в разделе про эвристики.) Иногда имеет смысл
заполнять элементы ответа не в том порядке, в котором приходит в голову,
а продумать, в каком. Например, пусть наша задача — дано :math:`N^2`
чисел, проверить, можно ли из них составить магический квадрат (т.е.
квадрат, в котором сумма каждой строки равна сумме каждого столбца).
Можно, конечно, перебирать так, как написано в предыдущем пункте: т.е.
выбирать значения для первой строки, потом для второй и т.д…Но можно
поступить так: в :math:`find(1)` перебираем значение клетки
:math:`(1,1)`, в :math:`find(2)` — :math:`(1,2)`, …\ :math:`find(n)` —
:math:`(1,n)`, :math:`find(n+1)` — :math:`(2,1)` и внимание!
:math:`find(n+2)` — :math:`(3,1)`, :math:`find(n+3)` — :math:`(4,1)` и
т.д., потом остаток второй строки, потом остаток второго столбца и т.д.,
в таблице справа следующего абзаца для :math:`N=5` приведены номера,
какая клетка какой по счету будет.

r4cm

+-----+------+------+------+------+
| 1   | 2    | 3    | 4    | 5    |
+=====+======+======+======+======+
| 6   | 10   | 11   | 12   | 13   |
+-----+------+------+------+------+
| 7   | 14   | 17   | 18   | 19   |
+-----+------+------+------+------+
| 8   | 15   | 20   | 22   | 23   |
+-----+------+------+------+------+
| 9   | 16   | 21   | 24   | 25   |
+-----+------+------+------+------+

Смысл в том, что в этой задаче есть естественное отсечение: если мы
заполнили очередную строку или столбец, то стоит сразу проверить, что
его сумма равна сумме всех чисел, делённой на :math:`N` (очевидно, что
именно такая должна быть сумма каждой строки и каждого столбца). Поэтому
стоит заполнять таблицу в таком порядке, чтобы проверять можно быть как
можно быстрее. Если заполнять построчно, то проверять можно будет после
первой строки (при глубине рекурсии :math:`N`), после второй
(:math:`2N`), после третьей (:math:`3N`), и т.д., зато в конце — на всей
последней строке будем проверять суммы столбцов.

А если делать заполнять по очереди строки и столбцы (как описано два
абзаца назад и показано в примере справа), то отсечения будут: после
первой строки (на глубине :math:`N`), после первого столбца (на глубине
:math:`2N-1`, а не :math:`2N` (!)), после второй строки (:math:`3N-2`, а
не :math:`3N`) и т.д. — т.е. отсечения будут раньше и программа будет
работать быстрее.

Аналогичные идеи могут быть и в других задачах, хотя, наверное, весьма
редко.

Вывод всех оптимальных решений
------------------------------

Пусть надо вывести *все* оптимальные решения. Можно, конечно, завести
большой массив, куда их записывать, но имхо проще поступить так: при
нахождении очередного оптимального решения просто выводить его сразу в
файл. Находится ещё одно столь же хорошее решение — его тоже выводим
туда же. Если же находится решение, которое ещё оптимальнее, чем все,
что было раньше, то делаем :math:`rewrite` — и все решения, которые были
выведены раньше, сотрутся. Это все делается в процедуре :math:`check`,
конечно.

Пример: пусть в задаче про удаление чисел надо было бы вывести *все*
оптимальные решения. Тогда пишем

::

    procedure check;
    var i:integer;
    begin
    if cur<best then begin
       best:=cur;
       rewrite(f);
       writeln(f,cur);
    end;
    if cur=best then  {это выполнится и в случае, когда только что нашлось еще более хорошее решение}
       for i:=1 to n-2 do write(f,a[i],' ');
    end;

Т.е. если нашлось решение ещё лучше, то :math:`rewrite` — потираем все
решения, что были найдены раньше, выводим новую оптимальную сумму (если,
конечно, требуется по условию), и делаем :math:`best:=cur`.

Далее, если :math:`cur=best`, а это теперь будет и если мы только что
нашли ещё более хорошее решение (т.е. если только что сделали
:math:`rewrite` и т.д.), и если мы просто нашли ещё одно столь же
хорошее решение, что и раньше, то выводим его.

Заметьте, что теперь массив :math:`ans` не нужен.

Не забудьте, что в таком случае уже нельзя делать отсечение по
нестрогому условию (т.е. :math:`\geq`), а только по строгому
(:math:`>`).

Кстати, ещё мысль. Аналогично можно поступить и если выводить надо
только одно решение. Можно его не сохранять в :math:`ans`, а сразу
выводить

::

    procedure check;
    var i:integer;
    begin
    if cur<best then begin
       best:=cur;
       rewrite(f);
       writeln(f,cur);
       for i:=1 to n-2 do write(f,a[i],' ');
       close(f);
    end;
    end;

За счёт :math:`close(f)` при отсечении по времени можно будет сразу
делать :math:`halt` — в каждый момент времени лучшее на данный момент
времени решение у нас уже лежит в файле, и при отсечении по времени вам
ничего вообще делать не надо, просто :math:`halt`.
