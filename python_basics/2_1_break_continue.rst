.. highlight:: python

Про команды break и continue
----------------------------

При работе с циклами есть две полезных команды — break и continue. Здесь
я опишу, что они делают и как их использовать.

Понятие тела цикла и итерации
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Сначала введу/повторю несколько терминов, которые полезны при обсуждении циклов.

**Тело** цикла — это собственно те команды, которые находятся внутри
цикла. Например, в цикле

::

    for i in range(1, n + 1):
        a = i * i
        print(i, a)
    

тело цикла состоит из двух команд: присваивания и вывода.

**Итерацией** называется каждый отдельный проход по телу цикла. Цикл
всегда повторяет команды из тела цикла несколько раз — вот каждое такое
повторение и называется итерацией. В примере выше можно сказать, что
цикл сделает *n* итераций. Можно, например, сказать, что на пятой
итерации цикла будет выведена строка "5 25".

Команда break
~~~~~~~~~~~~~

Команда break обозначает прервать выполнение цикла, и идти дальше
выполнять те команды, которые идут после цикла. Т.е. если вы в некоторый
момент решили, что больше вам циклиться не надо, и цикл уже отработал
все, что надо, и вам нужно переходить к тому, что написано после цикла,
то пишите break. Если это произошло посреди итерации, то итерация будет
прервана — тело цикла до конца выполнено не будет.

Пример:

::

    for i in range(2, n + 1):
        if n % i == 0:
            print(i)
            break
        print('Попробовали', i, ', не подходит')
    print('Конец!')

— как только условие if'а выполнится, на экран будет выведено
соответствующее *i*, и выполнение цикла будет прервано — дальше будет
выведено слово "Конец!" и т.д. При этом строка "Попробовали..." будет
выводиться для всех i, **не** включая то, на котором выполнилось условие
цикла.

Например, для ``n==9`` вывод будет следующий:

::

    Попробовали 2 , не подходит
    3
    Конец!

(Правда, данный конкретный код было бы проще написать через while —
подумайте, как)

Команду break можно также применять и с циклами while и repeat, один из
примеров будет ниже.

Команда continue
~~~~~~~~~~~~~~~~

Команда continue обозначает прервать выполнение текущей итерации цикла и
начать следующую итерацию. Т.е. как будто бы, не доделывая то, что
написано ниже в теле цикла, прыгнуть на начало цикла, при этом выполнив
все действия, которые должны быть выполнены после очередной итерации —
т.е. в цикле for увеличив значение счетчика цикла на 1, а в циклах
while/repeat проверив условие и, если оно не выполняется, то вообще
прервав работу.

Пример:

::

    for i in range(2, n):
        if n % i != 0:
            print('Попробовали', i, ', не подходит')
            continue
        print(n, 'делится на', i)

— здесь цикл пройдется по всем числам от ``2`` до ``n-1`` и для каждого выведет,
делится ли ``n`` на ``i`` или нет. Например, при ``n==9`` вывод будет такой:

::

    Попробовали 2 , не подходит
    9 делится на 3
    Попробовали 4 , не подходит
    ...
    Попробовали 8 , не подходит

Пройдем подробнее по началу выполнения этого кода. Сначала i становится
равным 2. Смотрим: ``9 % 2 != 0`` — значит, идем внутрь if. Выводим на
экран "Попробовали...", и далее идет команда continue. Значит, сразу
идем на следующую итерацию: увеличиваем ``i`` (!), оно становится равным 3,
и идем на начало цикла. ``9 % 3 == 0``, поэтому в if не идем, выводим "9
делится на 3", итерация закончилась — увеличиваем ``i`` и идем на следующую
итерацию. И так далее.

Конечно, в этом примере можно было бы обойтись и без ``continue``, просто
написать ``else``. Это было бы проще. Но бывает, что вам надо перебрать
числа, и есть много случаев, когда какое-то число вам не надо
рассматривать. Тогда писать кучу ``else`` было бы намного сложнее, чем
несколько ``continue``. Например (пример выдуман из головы, но подобные
случаи бывают):

::

    for i in range(n):
        # нам не нужны числа, делящиеся на 5
        if i % 5 == 0:
            continue
        # нам не нужны числа, квадрат которых дает остаток 4 при делении на 7
        # обратите внимание, что мы можем делать какие-то действия до проверки условий
        p = i * i
        if p % 7 == 4:
            continue
        # все оставшиеся числа нам нужны,
        # поэтому здесь делаем какую-нибудь сложную обработку из многих команд
        ...

— тут намного более понятно, что вы имели в виду, чем если бы вы писали
с ``else``. С ``else`` тому, кто будет читать ваш код, пришлось бы смотреть, где
``else`` заканчивается, и вдруг после конца ``else`` идут еще какие-нибудь
команды, а здесь все понятно: если ``if`` выполняется, то пропускается все
оставшееся тело цикла.

while True и break
~~~~~~~~~~~~~~~~~~~~~

Один важный случай применения команды ``break`` состоит в следующем. Часто
бывает так, что вам надо повторять какую-то последовательность действий,
и проверять условие окончания вам хочется в середине этой
последовательности. Например, вам надо считывать с клавиатуры числа,
пока не будет введен ноль. Все числа, кроме нуля, надо как-то
обрабатывать (для простоты будем считать, что выводить на экран — это
нам не существенно).

Естественная последовательность действий следующая:

::

    считать число
    если ноль, то прерваться
    вывести это число на экран
    считать число
    если ноль, то прерваться
    вывести это число на экран
    ...

Очень четко видна цикличность, но если вы попытаетесь написать цикл без
команды ``break``, ничего хорошего у вас не получится.

У вас будет несколько вариантов: например, так

::

    a = int(input())
    while a != 0:
        print(a)
        a = int(input())

Фактически вы "разрезали" циклическую последовательность действий на
проверке условия окончания цикла, и в результате были вынуждены команду
считывания числа задублировать: она у вас один раз перед циклом, и один
раз в конце цикла. Дублирование кода — это не очень хорошо (если вам
придется его менять, вы можете забыть, что один и тот же код в двух
местах); если у вас вместо считывания числа будет чуть более сложный
код, то будет еще хуже. Кроме того, в этой реализации не очень хорошо,
что у вас в пределах одной итерации цикла есть разные значения
переменной ``a``, было бы проще, если бы каждая итерация цикла
соответствовала работе только с одним введенным числом.

Второй вариант, который вам может придти в голову, такой:

::

    a = 1
    while a != 0:
        a = int(input())
        if a != 0:
            print(a)

Этот вариант лучше в том смысле, что каждая итерация работает только с
одним числом, но у него все равно есть недостатки. Во-первых, есть
искуственная команда ``a = 1`` перед циклом. Во-вторых, условие ``a != 0``
дублируется; если вам придется его менять, вы можете забыть, что оно
написано в двух местах. В-третьих, у вас *основная* ветка выполнения
цикла, ветка, по которой будет выполняться большинство итераций, попала
в ``if``. Это не очень удобно с точки зрения кода: все-таки все числа, кроме
последнего, будут не нулевыми, поэтому хотелось бы написать такой код, в
котором обработка случая ``a = 0`` не потребует заворачивания основного
варианта в ``if`` — так просто читать удобнее (особенно если бы у нас было
бы не просто ``print(a)``, а существенно более сложный код обработки
очередного числа, сам включающий несколько ``if``'ов и т.п.).

Но можно сделать следующим образом:

::

    while 0 == 0:
        a = int(input())
        if a == 0:
            break
        print(a)

Искусственная конструкция ``0==0`` — это условие, которое всегда верно: нам
надо, чтобы ``while`` выполнялся до бесконечности, и мог бы завершиться
только по ``break``. На самом деле в питоне есть специальное слово ``True``,
которое обозначает условие, которое всегда верно (и симметричное слово
``False``, которое обозначает условие, которое не верно никогда).
Соответственно, еще лучше писать ``while True:``...

Этот вариант свободен от всех указанных выше недостатков. Каждая
итерация работает с очередным числом, код считывания не дублируется, код
проверки не дублируется, общая последовательность действий понятна, и
основная ветка выполнения цикла находится в основном коде.

Вот так и следует писать любые циклы, в которых проверка условия нужна
*в середине* тела цикла:

::

    while True:
        что-то сделали
        if надо завершить работу:
            break
        сделали что-то еще
