.. highlight:: python

Циклы
=====

В программах довольно часто встречается необходимость повторить
некоторое действие несколько раз. Часто вы даже не знаете заранее,
сколько именно раз. Для этого существует специальная конструкция,
команда языка — цикл.

В питоне есть циклы двух типов.

(Я тут буду приводить примеры кодов. Конечно, экспериментируйте с ними
для лучшего понимания.)

Цикл while
----------

Цикл while — это простейший вариант цикла. Он выполняет некоторые
действия, после чего определяет, не надо ли их выполнить еще раз.
"Определяет" путем проверки указанного программистом условия. Выглядит
код так:

::

    while условие:
        код

Здесь ``условие`` — это условие в том же виде, в котором вы пишете
условие ``if``'а. Там могут быть сравнения, ``and``, ``or`` и т.д.

А ``код`` — это произвольная последовательность комад (может занимать и
несколько строк), содержащая любые команды, которые вы знаете или
узнаете потом: присваивания, if'ы, даже другие циклы и т.д.

Что будет делать компьютер, когда дойдет до такого цикла? Сначала он
проверит, выполняется ли условие. Если выполняется, то компьютер
выполнит указанный код и опять проверит условие. Если оно все еще
выполняется, то компьютер выполнит этот код еще раз, и так далее, до тех
пор, пока при очередной проверке не окажется, что условие не
выполняется. Тогда компьютер закончит выполнение цикла и перейдет к
коду, написанному после него.

Как может ``условие`` выполняться-выполняться, и вдруг перестать
выполняться? Очень просто: ``код`` может изменить какие-то переменные,
из-за которых условие перестанет выполняться. Собственно, в этом и
состоит весь смысл процесса. (А если ``код`` ничего такого не меняет, то
``условие`` будет выполняться всегда, и получится "бесконечный цикл" —
программа зависнет. Не делайте так.)

В частности, может быть так, что условие цикла не будет выполняться с
самого начала. Тогда цикл не выполнится ни разу, исполнение сразу
перейдет на команды после цикла.

Слово "while" переводится как "пока", т.е. вся запись цикла по сути
обозначает "пока выполняется ``условие``, делай ``код``".

Примеры
~~~~~~~

::

    n = int(input())
    a = 1
    while 2 * a < n:
        print(a)
        a += 1
    print("Done")

Что делает этот код? Он сначала считывает с клавиатуры значение ``n``.
Пусть для примера пользователь вводит число 5. Далее в переменную ``a``
записывается 1. А дальше начинается цикл.

Сначала компьютер проверяет, правда ли, что ``2 * a < n``.
Действительно, ``2*a`` равно 2, а ``n`` равно 5, условие выполняется.
Поэтому начинаем выполнять тот код, который написан внутри цикла. А
именно, выводим на экран ``a``, т.е. 1. И прибавляем единицу к ``a``,
получается ``a==2``. Код (говорят "тело цикла") закончился, поэтому
проверяем условие еще раз. Оно все еще выполняется (``2*a`` равно 4, а
``n`` равно 5), поэтому выполняем тело цикла заново. Выводим на экран 2
и увеличиваем ``a`` еще на единицу. Проверяем условие еще раз, оно уже
не выполняется (``2*a`` равно 6, а ``n`` равно 5), цикл закончился.

Цикл закончился, поэтому переходим на то, что после цикла — выводим на
экран Done.

Еще один пример, уже довольно навороченный:

::

    n = int(input())
    a = 1
    while a < n:
        b = a
        while b > 0:
            if b % 2 == 1:
                print(b, end=" ")
            b -= 1
        print()
        a *= 2

Здесь цикл, вложенный в цикл. Это работает следующим образом. Пусть
пользователь ввел 6. Переменная ``a`` становится равна 1.

Начинается внешний цикл (который ``while a < n``). Переменная ``b``
становится равна ``a``, т.е. 1. Пока ``b>0`` мы делаем следующее
(внутренний цикл): если ``b`` нечетное, то выводим на экран 1, после
чего уменьшаем ``b`` на 1. В итоге на экран выведется 1, после чего
``b`` станет равно 0, и внутренний цикл закончится.

Но внешний цикл еще продолжается. Выполняется команда ``print()``,
которая просто переводит строку, и переменная ``a`` увеличивается в 2
раза и становится равна 2. Проверяем условие цикла: ``a`` все еще меньше
``n``. Поэтому повторяем операции, но уже с новым ``a``. Переменная
``b`` становится равна 2, начинается внутренний цикл, сначала (при
``b==2``) на экран ничего не выводится (т.к. ``b`` четное), и ``b``
становится равно 1, потом на экран выводится 1, и ``b`` становится равно
0 и внутренний цикл заканчивается.

Продолжается внешний цикл, выводится перевод строки и ``a`` становится
равно 4. Это все еще меньше чем ``n``, поэтому входим заново во
внутренний цикл, ``b`` становится равно 4 ... и за весь внутренний цикл
на экран выводится 3 1 (я не буду уже подробно расписывать).

Далее опять выводим перевод строки, ``a`` становится равно 8, это уже
больше чем ``n``, поэтому внешний цикл закончился.

Цикл for
--------

Цикл ``while`` работает тупо: проверяет условие и выполняет код, и так
пока условие не перестанет выполняться. Это позволяет реализовать
практически любые правила зацикленности, какие нужны в задаче, и потому
часто применяется.

Но кроме того, довольно часто бывает так, что надо выполнить один и тот
же код несколько раз подряд, просто изменяя значения одной переменной
некоторым очень простым образом. Для этого есть цикл ``for``. Он пишется
так:

::

    for переменная in список_значений:
        код

Этот цикл работает так: указанной переменной присваивается первое
значение из списка, и выполняется код. Потом ей присваивается следующее
значение, и так далее.

Пример:

::

    for i in 7, 42, 137:
        print(i)

Этот код выведет на экран по очереди все три указанных числа (7, 42 и
137).

Список значений можно задавать как в примере выше, через запятую, а
можно и разными другими способами. Общие правила тут вы узнаете позже,
пока просто приведу наиболее распространенный вариант, который вам
сейчас чаще всего будет нужен (а вариант с явным перечислением значений,
как выше, вам сейчас довольно редко будет нужен).

А именно, очень часто вам надо, чтобы переменная цикла менялась,
перебирая числа в некотором диапазоне по порядку, например, 1, 2, 3, 4,
..., 10. Для этого есть конструкция ``range``. Пишется так:
``for i in range(1, 11)`` — это перебирает все числа от 1 (включительно)
до 11 (**невключительно**), т.е. как раз написанный выше набор чисел.
Еще раз, потому что важно: первое число включительно, второе
невключительно. Пример:

::

    for i in range(1, 21):
        print(i, "*", i, "=", i * i)

выводит на экран таблицу квадратов всех чисел от 1 до 20 включительно
(или до 21 невключительно).

У команды ``range`` можно не указывать первый параметр, тогда он будет
считаться равным 0: ``for i in range(4)`` переберет числа 0, 1, 2, 3.
Это может показаться странным и непоследовательным, но в следующей теме
(про массивы) вы поймете, что это очень естественно.

И наоборот, у команды ``range`` можно указать третий параметр — шаг, с
которым будет меняться значение переменной. Например, ``range(1, 7, 2)``
обозначает "от 1 (включительно) до 7 (невключительно) с шагом 2", т.е.
дает числа 1, 3, 5. Или ``range(0, 100, 10)`` дает числа 0, 10, 20, 30,
..., 90.

Особое применение этого третьего параметра — это перебор чисел в
обратном порядке. ``range(10, 0, -1)`` дает 10, 9, 8, ..., 1. Обратите
внимание, что 0 опять не включается. (Аналогично можно указывать шаг -2
и т.п.)

В ``range`` можно, конечно, указывать и переменные, выражения и т.д.
Например, ``range(a - b, a + b + 1)`` перебирает числа от ``a-b`` до
``a+b`` включительно (до ``a+b+1`` невключительно).

И напоследок — еще один, более сложный, пример применения цикла ``for``:

::

    for i in range(1, 10):
        for j in range(1, 10):
            print(i * j, end="")
        print()

выводит на экран таблицу умножения.
