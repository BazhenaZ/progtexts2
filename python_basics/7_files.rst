.. highlight:: python

Работа с файлами
=======================

На серьезных олимпиадах, а также во многих других ситуациях, вам надо
читать данные не с клавиатуры, а из файла, и выводить данные в файл, а
не на "экран". 

(В таком случае, конечно, вы должны знать имена этих файлов; в
задачах они, как правило, указаны, на этом сайте имена файлов почти
всегда — ``input.txt`` для входных данных и ``output.txt`` для выходных.)

Во многих языках программирования ввод/вывод данных через файлы очень
похож на ввод/вывод с клавиатуры — те же команды, только немного другие
параметры. В питоне, к сожалению, это не так.

Ввод данных
-----------

Самый простой способ ввести данные из файла в питоне — это сразу считать
их в массив строк. Это делается так:

::

    data = open("input.txt", "r").readlines()

Здесь ``input.txt`` — файл, откуда надо считать данные, параметр ``"r"``
указывает, что вы собираетесь именно *читать* (**r**\ ead) данные, а не
записывать (**w**\ rite, см. ниже). Команда ``open``, как говорят,
«открывает файл на чтение», а команда ``readlines`` считывает весь файл
в массив строк.

Теперь ``data`` — это массив строк, каждый элемент которого — это
очередная строка из входного файла. Например, если в файле было написано

::

    1 2 3
    4 5 6
    some text

то ``data`` будет содержать массив
``["1 2 3\n", "4 5 6\n", "some text\n"]``. 

Здесь ``"\n"`` — это символ
перевода строки, он будет на конце каждой строки массива ``data``,
кроме, возможно, последней. Если вы считываете числа, то можете о нем не
беспокоиться, а если считываете строки и он вам мешает, то, как правило,
от него можно избавиться командой ``a = a.rstrip("\n")``, где ``a`` —
строка, у которого вы хотите его убрать.

Каждый элемент массива ``data`` — это как результат отдельной команды
``input()``, которой вы пользовались для чтения с клавиатуры. Поэтому
дальше вы пишете программу так же, как писали и раньше, но вместо
каждого очередного обращения к ``input()`` вы обращаетесь к очередному
элементу массива ``data``. В простых случаях все просто, в более сложных
вам надо аккуратно подсчитывать, к какому именно элементу массива вам
надо обратиться.

Пример. Пусть во входном файле два числа по одному на строке. С клавиатуры
вы бы считывали так:

::

    a = int(input())
    b = int(input())

Тогда из файла надо считывать так:

::

    data = open("input.txt", "r").readlines()
    a = int(data[0])
    b = int(data[1])

Аналогично, если же два числа в одной строке. С клавиатуры это считывается так:

::

    a, b = map(int, input().split())

Тогда из файла считываем так:

::

    data = open("input.txt", "r").readlines()
    a, b = map(int, data[0].split())

Более сложный пример: сначала число ``N``, а потом ``N`` строк по одному
числу в каждой. С клавиатуры:

::

    n = int(input())
    for i in range(n):
        x = int(input())
        #... что-то делаем с x

Из файла:

::

    data = open("input.txt", "r").readlines()
    n = int(data[0])
    for i in range(n):
        x = int(data[i + 1])
        #... что-то делаем с x

Обратите внимание на то, что здесь написано ``i + 1`` — потому что в
первой (нулевой) строке было ``n``.

Вывод
-----

Проще всего выводить данные — записав их в одну большую строку и выведя
эту строку. Вывод строки в файл делается так:

::

    open("output.txt", "w").write(s)

здесь ``s`` — строка, которую нужно вывести. Это должна быть именно
строка, а не число и т.д. Используйте функцию ``str``, чтобы превратить
что угодно в строку, вручную добавляйте пробелы и переводы строк
(перевод строки записывается так: ``"\n"``).

Пример: пусть надо вывести два числа в одну строку::

    open("output.txt", "w").write(str(a) + " " + str(b))

Пусть надо вывести два числа на отдельных строках::

    open("output.txt", "w").write(str(a) + "\n" + str(b))

Пусть надо вывести массив чисел по одному числу на строке:

::

    s = ""
    for x in a:
        s = s + str(x) + "\n"
    open("output.txt", "w").write(s)

или проще, используя строковую магию:

::

    open("output.txt", "w").write("\n".join(a))

Имейте в виду, что такой вызов должен быть только один раз. Если вы
хотите вызывать функцию write несколько раз, то надо суметь вызвать
функцию open только один раз. Рекомендуемый вариант — такой:

::

    with open("output.txt", "w") as f:
        f.write("1")
        f.write("2")

Как это использовать в олимпиадах
---------------------------------

Основное достоинство ввода из файлов при решении алгоритмических задач
(на олимпиадах, тут на сайте и т.д.) — что вам не надо каждый раз заново
вводить весь тест. Если вы отлаживаете программу на некотором тесте,
разбираетесь, почему она не работает, пытаетесь исправить ошибки,
вы будете много раз запускать программу на одном и том же тесте.
Каждый раз его вводить — сложно и долго. Намного проще его один раз записать в файл,
и дальше делать ввод из файла.

Вторая причина использовать файлы — вы намного легче можете «жонглировать» тестами.
Вы можете записать несколько тестов в другой, вспомогательный, файл,
и просто копировать нужный тест во входной файл.
Более того, в большинстве случаев вы можете даже хранить много тестов
прямо во входном файле. 

А именно, во многих задачах у вас чтение данных идет не до конца файла
— например, вы считываете только два числа, или только одну строку, или вам 
задается число ``N`` и дальше ``N`` чисел — во всех этих случаях
программе не важно, что идет после этих данных. Вы там можете хранить
другие тесты, а потом, когда вам нужно, переносите просто нужный тест
в самое начало файла.

(А вообще, можете даже написать программу так, чтобы она обрабатывала
вообще все тесты, которые есть во входном файле — это так называемый мультитест.
На тестирующем сервере будет только один тест, и программа отработает только 
его, а при вашем тестировании программа будет сразу запускаться на многих тестах.
А еще, бывают задачи, где во входных данных сразу мультитест, т.е. задается сразу много тестов.
Тогда тем более вы можете тестировать сразу на многих тестах.)

Ну и при :ref:`стресс-тестировании <stresstesting>` ввод из файла вам тоже будет удобнее.
