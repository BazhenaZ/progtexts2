Быстрый линейный поиск
----------------------

Задача: дан массив :math:`a` из :math:`n` чисел (произвольный, т.е. в
частности не обязательно отсортированный), требуется найти в нем
заданное число :math:`k` или сообщить, что его в массиве нет. Тупое
решение:

::

    ans:=0;
    for i:=1 to n do
        if a[i]=k then begin
           ans:=i;
           break;
        end;

или что-нибудь подобное.

Посмотрим, сколько времени оно занимает. :math:`O(n)`, конечно, и ясно,
что быстрее не получится, т.к. надо каждый элемент массива просмотреть
хотя бы раз. Но поинтересуемся константой в :math:`O`-обозначении. На
одну итерацию цикла наша программа расходует одно сравнение в if, и —
внимание — одно сравнение в for (сравнивая :math:`i` с :math:`n`); кроме
того, одно увеличение :math:`i` на единицу и одно обращение к элементу
массива.

Обращение к элементу массива можно убрать стандартным приёмом — работой
с указателями, я про это напишу чуть ниже. А пока обращу внимание на
основное, что хочу тут написать: можно убрать и одно из двух сравнений!
А именно, напишем так:

::

    ans:=0;
    a[n+1]:=k;
    while a[i]<>k do
          inc(i);
    if i<>n+1 then
       ans:=i;

(if вне цикла тут).

Я добавляю в :math:`a[n+1]` дополнительный элемент, как раз равный тому,
что ищу. И теперь проверять, не кончился ли массив, мне не надо — как
только массив кончится, я тут же «найду» этот специально поставленный
элемент. Теперь в цикле на одно сравнение меньше. Только не забудьте,
что здесь требуется, чтобы в массиве было место под этот дополнительный
элемент (т.е. чтобы обращение к :math:`a[n+1]` не породило бы range
check error).

Можно и избавиться от обращения к элементу массива (это ведь умножение,
что может тормозить, хотя это есть умножение на размер элемента массива,
который чаще всего является степенью двойки и потому если компилятор
умный, то умножение будет работать быстро. Умный ли компилятор в
FP/Delphi, не знаю). Действительно, нам ведь надо смотреть элементы
*последовательно*, т.е. можно было бы завести указатель и просто его
последовательно увеличивать. К моему некоторому удивлению, синтаксис
паскаля (и FP, и Delphi) позволяет проделывать такие финты:

::

    var a:array[1..maxN] of integer;
        p:^integer;
    ...
    a[n+1]:=k;
    p:=@a;
    while p^<>k do
      inc(p);
    ...

Вроде должно работать. Что я тут делаю. Есть указатель :math:`p` на
текущий элемент массива. Изначально я кладу в него адрес :math:`a`, т.е.
фактически первого элемента :math:`a`. Команда inc, оказывается, умеет
увеличивать указатель как раз на размер соответствующего типа, т.е. в
данном случае сдвигать его к следующему элементу массива. Поэтому этот
код работает. Правда, не очень тривиально тут будет получить *номер*
найденного элемента (можно, конечно, параллельно с :math:`p` увеличивать
ещё какую-нибудь переменную, но это не интересно, т.к. затормозит
программу: сейчас у нас в цикле пара обращений по адресу, сравнение и
inc, что очень быстро. Дополнительный inc может несколько затормозить
программу). Можно посмотреть на значение указателя как ``integer``,
используя конструкцию ``absolute``...
