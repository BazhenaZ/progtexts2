% Исходный LaTeX-код (c) Пётр Калинин
% Код распространяется по лицензии GNU GPL (!)


\lheader{Быстрый линейный поиск} 
Задача: дан массив $a$ из $n$ чисел (произвольный, т.е. в частности не обязательно отсортированный), 
требуется найти в нем заданное число $k$ или сообщить, что его в массиве нет. Тупое решение:
\begin{codesampleo}\begin{verbatim}
ans:=0;
for i:=1 to n do
    if a[i]=k then begin
       ans:=i;
       break;
    end;
\end{verbatim}
\end{codesampleo}
или что"=нибудь подобное.

Посмотрим, сколько времени оно занимает. $O(n)$, конечно, и ясно, что быстрее не получится, 
т.к. надо каждый элемент массива просмотреть хотя бы раз. Но поинтересуемся константой в 
$O$-обозначении. На одну итерацию цикла наша программа расходует одно сравнение в if, и "--- 
внимание "--- одно сравнение в for (сравнивая $i$ с $n$); кроме того, одно увеличение $i$ на 
единицу и одно обращение к элементу массива.

Обращение к элементу массива можно убрать стандартным приёмом "--- работой с указателями, я 
про это напишу чуть ниже. А пока обращу внимание на основное, что хочу тут написать: можно 
убрать и одно из двух сравнений! А именно, напишем так:
\begin{codesampleo}\begin{verbatim}
ans:=0;
a[n+1]:=k;
while a[i]<>k do
      inc(i);
if i<>n+1 then
   ans:=i;
\end{verbatim}
\end{codesampleo}

(if вне цикла тут).

Я добавляю в $a[n+1]$ дополнительный элемент, как раз равный тому, что ищу. И теперь 
проверять, не кончился ли массив, мне не надо "--- как только массив кончится, я тут же 
"<найду"> этот специально поставленный элемент. Теперь в цикле на одно сравнение меньше. 
Только не забудьте, что здесь требуется, чтобы в массиве было место под этот дополнительный 
элемент (т.е. чтобы обращение к $a[n+1]$ не породило бы range check error).

Можно и избавиться от обращения к элементу массива (это ведь умножение, что может тормозить, хотя 
это есть умножение на размер элемента массива, который чаще всего является степенью двойки и потому 
если компилятор умный, то умножение будет работать быстро. Умный ли компилятор в FP/Delphi, не знаю). 
Действительно, нам ведь надо смотреть элементы \textit{последовательно}, т.е. можно было бы 
завести указатель и просто его последовательно увеличивать. К моему некоторому удивлению, синтаксис 
паскаля (и FP, и Delphi) позволяет проделывать такие финты:
\begin{codesample}\begin{verbatim}
var a:array[1..maxN] of integer;
    p:^integer;
...
a[n+1]:=k;
p:=@a;
while p^<>k do
  inc(p);
...
\end{verbatim}
\end{codesample}

Вроде должно работать. Что я тут делаю. Есть указатель $p$ на текущий элемент массива. Изначально я 
кладу в него адрес $a$, т.е. фактически первого элемента $a$. Команда inc, оказывается, умеет 
увеличивать указатель как раз на размер соответствующего типа, т.е. в данном случае сдвигать его к 
следующему элементу массива. Поэтому этот код работает. Правда, не очень тривиально тут будет 
получить \textit{номер} найденного элемента (можно, конечно, параллельно с $p$ увеличивать ещё 
какую"=нибудь переменную, но это не интересно, т.к. затормозит программу: сейчас у нас в цикле пара 
обращений по адресу, сравнение и inc, что очень быстро. Дополнительный inc может несколько
затормозить программу). Можно посмотреть на значение указателя как \verb|integer|, используя 
конструкцию \verb|absolute|...
