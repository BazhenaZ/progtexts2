% Исходный LaTeX-код (c) Пётр Калинин
% Код распространяется по лицензии GNU GPL (!)

\lheader{"<Бинарный"> ввод"=вывод} Вы прекрасно знаете, как вводить/выводить данные из/в файл, в 
котором данные записаны/должны быть записаны plain text, т.е. чистым текстом, который, не напрягаясь, может 
прочитать человек: вы используете тип text и все, что с ним связано. В результате все числа в файле 
получаются в виде последовательности десятичных цифр и т.п. Но обратите внимание, что это весьма 
неэкономный способ ввода/вывода: он требует довольно нетривиальной обработки по переводу числа из 
того вида, как оно записан в файле, в тот вид, в котором оно хранится в памяти компьютера и 
используется программой, и наоборот; кроме того, числа в файле занимают намного больше места, чем 
могли бы (для записи значения типа integer, например, может потребоваться 5 цифр + знак + пробел, в то 
время как на самом деле для кодирования значения integer достаточно двух байт). Основное 
достоинство такого формата состоит в том, что его может без особых раздумий прочитать человек.

Но бываю случаи, когда простота ввода/вывода и занимаемое место становится более важно, чем 
"<читабельность"> вывода. Для этого существует возможность записывать данные в файл непосредственно 
так, как они хранятся в памяти: если в памяти число 28454 ($={\rm6F26}_{16}$) типа integer занимает 2
байта, в которые записаны значения 111 ($={\rm6F}_{16}$) и 38 ($=26_{16}$) (с точностью до порядка 
байт, см. ниже), то и в файле это же число займёт два байта, в которые будут записаны те же 
значения 6F и 26. Файлы, в которые данные записаны таким способом, часто называют "<бинарными"> (а 
обычные файла в этом смысле "--- "<текстовыми">),  
соответственно такой способ ввода/вывода можно называть "<бинарным">. В паскале такой способ 
ввода/вывода можно осуществлять с помощью переменных типа file и file of.

\textbf{file of.} Пусть вам надо вводить/выводить в/из файла последовательность данных одного и 
того же типа (этот тип может быть каким угодно: как "<стандартным">, типа integer, так и "<шаблоном">,
определённым через команду type, в том числе record, array и т.п.). Тогда вы можете написать, 
например, следующую программу:
\begin{codesample}\begin{verbatim}
var f:file of integer;
    a,b,c:smallint;
    
begin
assign(f,'input.dat');reset(f);
read(f,a,b,c);
close(f);
end.
\end{verbatim}
\end{codesample}
\noindent при этом из файла input.dat будут считаны первые шесть байт и напрямую записаны в память:
первые два байта "--- по адресу переменной $a$, вторая пара байт "--- $b$, третья пара 
байт "--- $c$.

Вообще, тип \texttt{file of \textit{тип}} используется для такого бинарного ввода/вывода. Команды 
assign и reset/\linebreak[0]rewrite имеют, видимо, тот же смысл, что и для переменных типа text (хотя я точно не 
знаю, будет ли ввод/вывод буферизован; по крайней мере, команду settextbuf использовать точно не 
получится). После этого вы можете командами read/write читать/записывать данные, но теперь уже 
только переменные того типа, который вы указали в конструкции file of (т.е. если вы написали file 
of longint "--- то только переменные типа longint). В файл будут записываться данные 
непосредственно так, как они хранятся в памяти и считываться в память они будут аналогично. Каждая 
запись/чтение одной переменной будет записывать/считывать ровно столько байт, сколько занимают 
переменные этого типа в памяти. Обратите внимание, что readln/writeln здесь бессмысленен, т.к. 
переводы строк "--- это особенности чисто текстовых файлов.

Ещё раз подчеркну, что использовать тут можно любые типы "--- как стандартные, так и свои, 
определённые через команду type:
\begin{codesample}\begin{verbatim}
type tData=record
             a,b,c:integer;
             d:single;
             s:string[30];
           end;
           
var f:file of tData;
    d:tData;
begin
assign(f,'input.dat');reset(f);
read(f,d);
...
\end{verbatim}
\end{codesample}

или
\begin{codesampleo}\begin{verbatim}
type tArr=array[1..30] of integer;
var f:file of tArr;
\end{verbatim}
\end{codesampleo}
и т.п.

\textbf{file.} Такой тип данных подразумевает, что файл состоит из некоторого количества 
"<записей">, каждая "<запись"> имеет одну и ту же длину. Длина записи (в байтах) указывается 
\textit{вторым параметром команд reset/rewrite}, т.е. эти команды требуют тут \textit{два} 
параметра. После этого единственная команда, которой можно работать с файлом "--- это blockread или 
blockwrite. Они принимают три параметра: переменную типа file, откуда читать/куда писать, дальше переменную 
\textit{любого} типа, которая указывает адрес памяти, куда/откуда писать, и количество "<записей">, которые 
надо прочитать/записать. Команды не выполняют \textit{вообще} никакой проверки на соответствие типов, на то, 
что вся память, куда/откуда вы хотите писать, действительно выделена вам и т.д. Пример:
\begin{codesample}\begin{verbatim}
type tData=record
             a,b,c:integer;
             d:single;
             s:string[30];
           end;
           
var f:file;
    d:array[1..10] of tData;
begin
assign(f,'input.dat');reset(f,sizeof(tData));
blockread(f,d,10);
...
\end{verbatim}
\end{codesample}

Размер "<записи"> здесь делается равным размеру типа tData, поэтому команда blockread считывает 10 
"<записей">, тем самым как раз заполняя весь массив d.

\pagebreak[3]

На самом деле понятие "<записи"> не очень важно: паскаль далеко не требует, чтобы это было 
что"=нибудь осмысленное (например, размер элемента массива), единственный смысл этого понятия "--- 
на размер записи умножается третий аргумент команд blockread/blockwrite, чтобы получить количество 
байт, сколько надо считать. Поэтому следующие две программы равносильны и равносильны первой (с 
точностью до того, что эти программы записывают данные, а не считывают):
\begin{codesample}\begin{verbatim}
type tData=record
             a,b,c:integer;
             d:single;
             s:string[30];
           end;
           
var f:file;
    d:array[1..10] of tData;
...  
assign(f,'input.dat');rewrite(f,2*sizeof(tData));
blockwrite(f,d,5);
...
\end{verbatim}
\end{codesample}
\begin{codesample}\begin{verbatim}
type tData=record
             a,b,c:integer;
             d:single;
             s:string[30];
           end;
           
var f:file;
    d:array[1..10] of tData;
...  
assign(f,'input.dat');rewrite(f,1);
blockwrite(f,d,sizeof(d));
...
\end{verbatim}
\end{codesample}

Обратите внимание на последнюю программу: здесь я указываю, что размер записи равен 1, и далее 
просто указываю количество байт, сколько надо считать. ИМХО, так делать в большинстве случаев 
удобнее всего: в команде reset/rewite писать 1, а в blockread/blockwrite писать точное количество 
байт (используя sizeof при необходимости). Если бы я захотел считать 8, а не 10 элементов (т.е. 
массив не полностью, то я бы написал blockread(f,d,8*sizeof(tData)). Ещё зацените следующую 
программу: я тут храню сначала количество элементов, а потом сами элементы:
\begin{codesample}\begin{verbatim}
...
var f:file;
    d:array[1..10] of tData;
    n:integer;
...  
assign(f,'input.dat');reset(f,1);
blockread(f,n,sizeof(n));
blockread(f,d,n*sizeof(tData));
...
\end{verbatim}
\end{codesample}
Таким образом можно хранить в бинарном файле данные совершенно разных типов вперемешку.

Ещё раз подчёркиваю, что \textit{никаких} проверок blockread/blockwrite не делает, а тупо копирует 
сколько указано байт. Если в последнем примере получится $n>10$, то никакого вам Range check error 
даже при включённом \verb'{$R+}' не будет "--- blockread просто \textit{не знает}, что ему 
подсунули массив из 10 элементов. Для него второй аргумент "--- это просто адрес места в 
памяти.

Ещё пара общих замечаний (и к file, и к file of). Во"=первых, на разных системах (ОС или вообще 
архитектурах компьютеров) может быть разный порядок байт: число 28454 
может представляться в памяти как два байта 6F~26, так и как два байта 26~6F (сравните, как вы 
храните числа в длинной арифметике); с четырехбайтовыми числами все ещё хуже. 
Можете поэкспериментировать, чтобы проверить, какой порядок в 
Windows. Поэтому бинарный файл, записанный на одном компьютере, может не прочитаться на другом.

Во"=вторых, выравнивание "--- то самое, на которое влияет ключ \verb|$A|, см. выше. Все программы, которые пишут, например, record'ы в 
бинарные файлы, должны учитывать возможность выравнивания: если файл записан с одними настройками выравнивания, а 
прочитан с другими, то это может вызвать проблемы. Я обычно в таких случаях специально ставлю ключ 
компилятора \verb'{$A-}', чтобы гарантированно совсем отключить выравнивание.

